<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛枫的天空</title>
  <icon>https://www.gravatar.com/avatar/df0e7d70e66695a1b4e50e51e865390b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.luofeng.com/"/>
  <updated>2017-11-25T09:27:05.960Z</updated>
  <id>http://www.luofeng.com/</id>
  
  <author>
    <name>洛枫</name>
    <email>weixia.banxia@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无关记事</title>
    <link href="http://www.luofeng.com/2017/11/26/%E6%97%A0%E5%85%B3%E8%AE%B0%E4%BA%8B/"/>
    <id>http://www.luofeng.com/2017/11/26/无关记事/</id>
    <published>2017-11-25T17:26:38.000Z</published>
    <updated>2017-11-25T09:27:05.960Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://wx4.sinaimg.cn/mw690/006d4LTCgy1fluggj8lhqj315r0tze82.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所谓孤独，就是哪怕周围再多人，感觉还是一个人。</p><p>冬季的早晨总是来得更晚，醒的时候，阳光已落进阳台。我想起朱自清先生的匆匆，想象那束光，是怎样在我不知觉时爬过窗台，爬过地砖间的缝隙。又想起验证地球自转的单摆实验，是怎样的摆针，怎样的沙盘，怎样地摆到现在。</p><p>我总以为一个人有了书，就会花时间去看，买了相机能很自然地出街，穿上新衣服便不再惧怕拍照，带着戒指意味着存在责任。然而，人终究被关在暗无天日里，没有无聊，便做些更无聊的事。或者突如其来地刷下装箱的旧鞋，或者躲在房间的角落，熄灭一支未尽的香烟。</p><p>多年未见的朋友突然来信，让人觉着生活仍是真实存在的，任你多想抛弃掉某些事实，它总能不经意间将你打醒。我在想，大抵我们之间已无恩怨，至于想不想交个新朋友，对现时的我来说，已无所谓有也无所谓无了。</p><p>十一月已到下旬，社交昵称总没再改，以前暗自庆幸的小把戏似乎显得幼稚。新的恋情自然向前，工作也不乏光彩。执笔时太阳已落到长河街的另一端，跟着去的，还有不绝的车流。单摆的摆针摆向明天，孤独将在明早的阳光中复现，毫不褪色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>认识Servlet</title>
    <link href="http://www.luofeng.com/2017/11/23/%E8%AE%A4%E8%AF%86Servlet/"/>
    <id>http://www.luofeng.com/2017/11/23/认识Servlet/</id>
    <published>2017-11-22T22:30:48.000Z</published>
    <updated>2017-11-22T14:34:30.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet工作流"><a href="#Servlet工作流" class="headerlink" title="Servlet工作流"></a>Servlet工作流</h3><ol><li>浏览器通过Request向服务器发起请求，具体请求某个servlet</li><li>web容器调用Servlet的service方法，具体交给实现类的特定方法</li><li>Servlet处理完浏览器发来的请求之后，通过Response把结果返回</li></ol><h3 id="Servlet实现"><a href="#Servlet实现" class="headerlink" title="Servlet实现"></a>Servlet实现</h3><ol><li>Servlet是指javax.servlet.Servlet接口，默认定义了init、service、destroy等方法</li><li>其中init方法，在web容器实例化该servlet后调用一次，在init之后，这个servlet就被放入web服务中，只要当前服务不关，不管后续请求过多少次，都不会再调用。</li><li>service方法，真正处理浏览器请求的方法，在每次发起请求时都会被自动调用，接受一个ServletRequest和一个ServletResponse参数，分别封装了请求信息和响应信息。</li><li>destroy方法，与init方法对应，该方法在整个服务退出时被调用，调用后当前servlet无法再接收请求，意味着生命周期的结束。</li><li>GenericServlet是Servlet接口的实现类，需要自己重构Servlet时，一般从该类继承，也是Servlet类的鼻祖。</li><li>HttpServlet，继承自GenericServlet，是专门处理http协议的Servlet，其中定义了doGet和doPost，会根据http请求的方式自动调用，是最常用Serlter类。</li></ol><h3 id="第一个Servlet"><a href="#第一个Servlet" class="headerlink" title="第一个Servlet"></a>第一个Servlet</h3><p>程序世界里，第一个永远是 Helloworld! </p><ol><li><p>新建class，HelloworldServlet继承自HttpServlet，然后打印Hello World!</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloworldServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置当前Servlet信息，其中servlet-name是给这个Servlet的唯一标识，通过<servlet>标签和<servlet-mapping>标签中的servlet-name字段，把前台url和后台调用的Servlet.class联系起来。</servlet-mapping></servlet></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloworldServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloworldServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloworldServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloworld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>servlet-class是相对与当前web应用输出classes目录为根路径，默认为WEB-INF/classes/，因此如果是带包名的Servlet，这里的servlet-class也应该是全名。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Servlet工作流&quot;&gt;&lt;a href=&quot;#Servlet工作流&quot; class=&quot;headerlink&quot; title=&quot;Servlet工作流&quot;&gt;&lt;/a&gt;Servlet工作流&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;浏览器通过Request向服务器发起请求，具体请求某个servl
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.luofeng.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Servlet" scheme="http://www.luofeng.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>B/S交互</title>
    <link href="http://www.luofeng.com/2017/11/21/BS%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.luofeng.com/2017/11/21/BS交互/</id>
    <published>2017-11-20T23:19:16.000Z</published>
    <updated>2017-11-20T16:19:16.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B-S交互概述"><a href="#B-S交互概述" class="headerlink" title="B/S交互概述"></a>B/S交互概述</h3><p>B/S交互，无非是用户通过浏览器敲一个地址或者其它形式向服务器发起一个请求，或请求资源或发送指令，然后服务器根据浏览器发来的请求做逻辑处理，最后向浏览器返回一些结果。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>协议就是一斤Apple五块钱，别人给你一斤苹果你不会给十块钱也不会给两块钱。HTTP协议就是浏览器和服务器之间交流的一种规则，这种规则规定了一系列的格式，但是这种规则是无连接的，在处理完一次Request-Response之后就会断开。</p><h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><p><code>GET</code> 和 <code>POST</code> 是最常用的访问方式，除此之外还有 <code>HEAD</code>、<code>DELETE</code>、<code>TRACE</code>、<code>PUT</code>、<code>OPTIONS</code> 5种访问方式</p><ol><li>GET方式<br>从浏览器地址栏输入网址，这种访问方式都是Get，Get方式的请求会把参数以key=value的形式带入到url中去，例如百度搜索Java，访问的链接就是<code>http://www.baidu.com/s?wd=Java</code> 并且Get方式提交的地址不能超过256(2的8次方)个字符。</li><li>POST方式<br>一种场景是当请求的字符长度超过256个字符时，就必须使用Post方式，例如上传文件，还有一种是不想把敏感信息放入到url，例如密码信息，当然一般来说是不会有明文密码这种出现（通过协定好的加密解密方式）。Post方式一般要手动设置Content-Type和Content-Length，参数以键值对方式设置。</li></ol><h3 id="Java-Web中的实现"><a href="#Java-Web中的实现" class="headerlink" title="Java-Web中的实现"></a>Java-Web中的实现</h3><p>首先明确的是，Java-Web中所有的Request-Response都是由 <code>Servlet</code>来完成的，Servlet是Java对于web交互的一种标准，而被web应用容器实现，例如 <code>Tomcat</code>，因此我们的web应用能够在这些容器中运行。一个Java程序应该是从main方法开始执行的，但是Servlet中没有main方法，而是在请求发送至服务端时，这些容器自动去调用Servlet中的某些方法。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;B-S交互概述&quot;&gt;&lt;a href=&quot;#B-S交互概述&quot; class=&quot;headerlink&quot; title=&quot;B/S交互概述&quot;&gt;&lt;/a&gt;B/S交互概述&lt;/h3&gt;&lt;p&gt;B/S交互，无非是用户通过浏览器敲一个地址或者其它形式向服务器发起一个请求，或请求资源或发送指令，然
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.luofeng.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="HTTP" scheme="http://www.luofeng.com/tags/HTTP/"/>
    
      <category term="Request-Response" scheme="http://www.luofeng.com/tags/Request-Response/"/>
    
      <category term="Java-Web" scheme="http://www.luofeng.com/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>web application基础知识</title>
    <link href="http://www.luofeng.com/2017/11/20/web%20application%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.luofeng.com/2017/11/20/web application基础知识/</id>
    <published>2017-11-19T22:59:42.000Z</published>
    <updated>2017-11-20T15:08:06.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web-application"><a href="#web-application" class="headerlink" title="web application"></a>web application</h3><p>一个符合标准的 web appliction</p><ul><li>应该包含WEB-INF文件夹</li><li>该文件夹下必须包含web.xml文件</li><li><p>该文件的内容至少包含</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"3.1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>它的目录层级应该是这样的，其中必要条件只有上述3个</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AppName</span><br><span class="line">WEB-INF</span><br><span class="line">web.xml</span><br><span class="line">lib（存放类库）</span><br><span class="line">classes（存放编译好的Class）</span><br><span class="line">META-INF（存放上下文信息，符合j2ee标准）</span><br><span class="line">other（存放其它的一些文件）</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>在tomcat的webapps目录下创建test应用</li><li>按照上述标准在test目录下创建相应文件内容</li><li>在test目录下创建helloworld.html，内容为 <code>Hello World!</code></li><li>启动tomcat</li><li>浏览器访问 <a href="http://127.0.0.1:8080/test/helloworld.html" target="_blank" rel="noopener">http://127.0.0.1:8080/test/helloworld.html</a></li><li>浏览器上显示 Hello World!</li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol><li>直接访问tomcat默认端口时，其实是访问名为webapps/ROOT这个应用</li><li>一般地，webapplication放在tomcat的webapps底下，访问时用默认地址端口/应用名</li><li><p>如果不放在webapps目录下，可以在tomcat/conf/server.xml的Host节点中添加<context>节点，一个Context就相当于一个webapp。节点中的path指跟在tomcat默认端口后的访问路径，一定是以“/”开头，docBase指webapp的物理路径，可以是相对路径和绝对路径，其中相对路径是指与appBase（webapps）相对的路径。</context></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">docBase</span>=<span class="string">"D:\ workspace\hello\WebRoot"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">privileged</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web-application&quot;&gt;&lt;a href=&quot;#web-application&quot; class=&quot;headerlink&quot; title=&quot;web application&quot;&gt;&lt;/a&gt;web application&lt;/h3&gt;&lt;p&gt;一个符合标准的 web applic
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.luofeng.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webapp" scheme="http://www.luofeng.com/tags/webapp/"/>
    
      <category term="tomcat" scheme="http://www.luofeng.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>春秋</title>
    <link href="http://www.luofeng.com/2017/01/15/%E6%98%A5%E7%A7%8B/"/>
    <id>http://www.luofeng.com/2017/01/15/春秋/</id>
    <published>2017-01-14T20:56:15.000Z</published>
    <updated>2017-11-25T09:28:25.324Z</updated>
    
    <content type="html"><![CDATA[<p>长这么大，好像还是第一次进医院，不是什么大事，也有些心慌慌的，所谓初生牛犊不怕虎，大概如此。做过不少梦，幻想过许多美好的事，没来得及做或者做得更好。有一段时间，大脑像被抽成空白，然后疯狂地去补别人的故事，每逢过节，伪装成失落的恋人，在漆白的桦树林间偶遇谁，沿断桥的河岸线错过谁，从人群的雨伞下回望谁，让公车的玻璃窗画了谁，好像自己是每个故事的主角。我有点分裂，还是活着像个演员。<br>原来就经常头痛，现在又多了胃痛，不知道肾好不好，神经衰弱，然后心理也有点抑郁，去办银行卡人家说我话都说不好不给我办，车也不会骑每次都变成别人的累赘。苟延残喘是一回事，要是被说没上进心是另一回事，被人收做妹妹也是另一回事。<br>记得有一次是哪个假期，去看哪个同学的家人，同学是女同学，不确切是哪个，那个时候以为一定会记一辈子，没想到现在就忘了，那里和港口很近，过了一条街就是长堤，落日的余辉随波起伏，退潮的堤岸边被种上时令蔬菜，有游玩的情侣在互相拍照，身后是城市的音乐声，远方依旧是金鳞的水面，一望无际，货船只是呜呜向前。<br>今天没事听起了半岛铁盒，它是一本书吗，如果是那去哪里买呢。某伦已经身为人父了，感谢在我的生命里有过他的演唱会。<br>很庆幸当我睁开眼的时候，依然能看到你，白天，外面阳光灿烂，把自己关在开灯的房间里，季围巾戴帽子，不发出声音，就是来回走。我想，如果明天，我不再存在，请你记得，今天我喜欢过你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;长这么大，好像还是第一次进医院，不是什么大事，也有些心慌慌的，所谓初生牛犊不怕虎，大概如此。做过不少梦，幻想过许多美好的事，没来得及做或者做得更好。有一段时间，大脑像被抽成空白，然后疯狂地去补别人的故事，每逢过节，伪装成失落的恋人，在漆白的桦树林间偶遇谁，沿断桥的河岸线错过
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>再见理想</title>
    <link href="http://www.luofeng.com/2016/10/24/%E5%86%8D%E8%A7%81%E7%90%86%E6%83%B3/"/>
    <id>http://www.luofeng.com/2016/10/24/再见理想/</id>
    <published>2016-10-24T08:53:07.000Z</published>
    <updated>2017-11-25T09:27:25.526Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=5266094&auto=1&height=66"></iframe><h1 id="再见理想"><a href="#再见理想" class="headerlink" title="再见理想"></a><a href="#再见理想" title="再见理想"></a>再见理想</h1><p>从九阳小店回去的时候，天就突然下起雨了，雨滴在门牌延伸的牛皮毡布上，噼啪噼啪的，像腊月深冬里的雪子，小店的砂锅气灶就摆在毡布下，沿街吹过的风，让幽紫色的火焰一闪一闪，沸腾溢出的汤水，在锈掉的金属灶具上滋一下就没了，老板忙着招呼客人，玻璃门内流出一股暖黄色的光，我到隔壁便利店买十块钱一包的烟，靠着墙根狭窄的干处往回走，路上浓密的墨点越来越重，小巷尽头，勾勒出农家枣树的稀疏掠影。</p><p>辗转数月，去过几个城市，见过不同地方的人。假如把自己置身世外，看广场上被俗世溜达的宠客，看晴晚远飞的流浪航班的警灯，看一群不知所云的方言嬉笑，</p><p>一个月了，知道所谓假如是没有假如的，我成了在城市街道上往来的实体，被运输工具置于生活与工作的两极。七点整，沿深巷往路口走，听到各式各样的闹铃，一边讥讽这些机械声线存在的意义，一边自豪着成为生物钟的异样光辉。晚上六点下班，城市的夜华灯初上，有些人的生活才刚刚开始，我钟情王菲唱的末班车，钟情夜色深处的暧昧红色。</p><p>雨下了好久，城市的桂树花开了又谢，撑一把黑色雨伞，去勤业路的便民超市买米，一辆私家车的前窗落满桂花花瓣，颜色很新，想来昨夜风雨严峻，自己却一无所知。最是人间留不住，下一句是什么。</p><p>时间是窗前一幢幢砖红色的屋顶，我数着数着的时候就真的失掉了，一开始还是秒、分钟、小时，后来就变成天、星期、月了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Design设计</title>
    <link href="http://www.luofeng.com/2016/09/09/Design%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.luofeng.com/2016/09/09/Design设计/</id>
    <published>2016-09-09T08:15:53.000Z</published>
    <updated>2017-11-25T09:28:46.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Design设计"><a href="#Design设计" class="headerlink" title="Design设计"></a><a href="#Design设计" title="Design设计"></a>Design设计</h1><p>在开发之前导入design包<code>com.android.support:design</code>，design包是跟随android5.0一起提出的，配合Material Design有非常好看的效果</p><h2 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a><a href="#TabLayout" title="TabLayout"></a>TabLayout</h2><p>选项卡的标签布局，配合ViewPager使用，首先在XML布局文件中引入<br>      <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span><br><span class="line">         <span class="attr">android:id</span>=<span class="string">“@+id/tab”</span></span><br><span class="line">         <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">         <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">         <span class="attr">…</span></span><br><span class="line">         &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.TabLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>TabLayout专有属性要在独立命名空间下，在布局文件的根布局下引入</p><pre><code>xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;`&lt;/pre&gt;这里署名为`app`，则在下面属性也要用`app`，下面是一些属性，标签文字的大小无法直接用`size`属性指定，只能用`tabTextAppearance`属性直接指定style样式&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app:tabBackground=&quot;@color/colorPrimary&quot; //标签栏的背景&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;app:tabTextColor=&quot;@android:color/white&quot; //未选中标签文字的颜色&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;app:tabIndicatorColor=&quot;@android:color/white&quot; //滑块的颜色&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;app:tabSelectedTextColor=&quot;@color/colorAccent&quot; //选中标签文字的颜色&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;app:tabMode=&quot;scrollable&quot; //标签的模式，如果标签比较多时会跟随页面滚动&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;java代码中与ViewPager联动&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ViewPager pager = (ViewPager) findViewById(R.id.pager);&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;TabLayout tab = (TabLayout) findViewById(R.id.tab);&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;MyAdapter adapter=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyAdapter(getSupportFragmentManager(),list);&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;pager.setAdapter(adapter);&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;tab.setupWithViewPager(pager); &lt;span class=&quot;comment&quot;&gt;//在pager内容设置好后，设置与TabLayout的联动&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;TabLayout标签上的文字来自于ViewPager，需要重写adapter的`getPageTitle()`方法&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CharSequence &lt;span class=&quot;title&quot;&gt;getPageTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; position)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list.get(position);&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;## [](#DrawerLayout &quot;DrawerLayout&quot;)DrawerLayout包括内容和抽屉(`NavigationView`)，可以选择覆盖toolbar或者跟toolbar联动，覆盖只需要把toolbar布局作为DrawerLayout内容的一部分，不覆盖则DrawerLayout应该在toolbar的下方，可以拥有抽屉的一个汉堡动画</code></pre><ul><li><strong>Toolbar</strong><br>Toolbar用来代替ActionBar可以更自由的摆放<br>  1.backgruound属性用来指定toolbar的背景，theme属性用来指定整个主题，<code>@style/ThemeOverlay.AppCompat.Dark.ActionBar&amp;quot;</code>这个主题前景色是白色  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span><br><span class="line">     <span class="attr">android:id</span>=<span class="string">“@+id/toolbar”</span></span><br><span class="line">     <span class="attr">android:background</span>=<span class="string">“@color/colorPrimary”</span></span><br><span class="line">     <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">     <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">app:theme</span>=<span class="string">“@style/ThemeOverlay.AppCompat.Dark.ActionBar”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  2.在设置toolbar之前，应该先把程序原来的actionBar去掉，换NoActionBar的主题，例如<code>Theme.AppCompat.Light.NoActionBar</code><br>  3.在setContentView()方法之后，找到toolbar然后设置，<code>setDisplayHomeAsUpEnabled()</code>方法可以添加一个箭头图标，在有父Activity时能够返回<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Toolbar toolbar= (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br><span class="line">getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>NavigationView</strong><br>扮演抽屉导航中的抽屉，必须设置<code>layout_gravity</code>属性，代表向哪个方向滑动，特有属性也是在<code>app</code>命名空间下</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span><br><span class="line">     <span class="attr">android:id</span>=<span class="string">“@+id/drawer”</span></span><br><span class="line">     <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">     <span class="attr">android:layout_height</span>=<span class="string">“match_parent”</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">LinearLayout</span></span><br><span class="line">         <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">         <span class="attr">android:layout_height</span>=<span class="string">“match_parent”</span>&gt;</span></span><br><span class="line">        …</span><br><span class="line">     <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span><br><span class="line">         <span class="attr">android:id</span>=<span class="string">“@+id/nav”</span></span><br><span class="line">         <span class="attr">android:layout_gravity</span>=<span class="string">“start”</span></span><br><span class="line">         <span class="attr">app:menu</span>=<span class="string">“@menu/navigation”</span></span><br><span class="line">         <span class="attr">app:headerLayout</span>=<span class="string">“@layout/header”</span></span><br><span class="line">         <span class="attr">app:itemTextColor</span>=<span class="string">“@color/item_bg_select”</span></span><br><span class="line">         <span class="attr">app:itemIconTint</span>=<span class="string">“@color/item_bg_select”</span></span><br><span class="line">         <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">         <span class="attr">android:layout_height</span>=<span class="string">“match_parent”</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">android.support.design.widget.NavigationView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  1.设置抽屉里的菜单<br>  新建menu文件，<code>group</code>标签内的<code>item</code>是一组单选菜单，有选中和未选中之分，item-menu-item承接出来的菜单有子菜单的效果，会有一条横线隔开<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">“<a href="http://schemas.android.com/apk/res/android" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android</a>“</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">“single”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span><br><span class="line">            <span class="attr">android:id</span>=<span class="string">“@+id/single_1”</span></span><br><span class="line">            <span class="attr">android:icon</span>=<span class="string">“@mipmap/ic_launcher”</span></span><br><span class="line">            <span class="attr">android:title</span>=<span class="string">“单选1”</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span><br><span class="line">            <span class="attr">android:id</span>=<span class="string">“@+id/single_2”</span></span><br><span class="line">            <span class="attr">android:icon</span>=<span class="string">“@mipmap/ic_launcher”</span></span><br><span class="line">            <span class="attr">android:title</span>=<span class="string">“单选2”</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">“子菜单”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span></span><br><span class="line">                <span class="attr">android:id</span>=<span class="string">“@+id/nav_item_1”</span></span><br><span class="line">                <span class="attr">android:icon</span>=<span class="string">“@mipmap/ic_launcher”</span></span><br><span class="line">                <span class="attr">android:title</span>=<span class="string">“菜单1”</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span></span><br><span class="line">                <span class="attr">android:id</span>=<span class="string">“@+id/nav_item_2”</span></span><br><span class="line">                <span class="attr">android:icon</span>=<span class="string">“@mipmap/ic_launcher”</span></span><br><span class="line">                <span class="attr">android:title</span>=<span class="string">“菜单2”</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><br>   在NavigationView中配置<code>app:menu</code>属性，即上面的menu文件      2.设置抽屉里的header，显示用户的头像和用户名<br>  新建header布局文件，写死header的高度，设置背景色，添加Imageview和Textview承载用户头像和名字<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">“<a href="http://schemas.android.com/apk/res/android" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android</a>“</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“200dp”</span></span><br><span class="line">    <span class="attr">android:gravity</span>=<span class="string">“center”</span></span><br><span class="line">    <span class="attr">android:background</span>=<span class="string">“@drawable/header_bg”</span></span><br><span class="line">    <span class="attr">android:orientation</span>=<span class="string">“vertical”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span><br><span class="line">        <span class="attr">android:src</span>=<span class="string">“@mipmap/ic_launcher”</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">“16dp”</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:text</span>=<span class="string">“用户名”</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  在NavigationView中配置<code>app:headerLayout</code>属性，即上面的layout文件      3.设置抽屉的监听事件和与toolbar的联动<br>  寻找到drawerlayout后利用ActionBarDrawerToggle对象控制toolbar上的图标与抽屉的联动<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drawer = (DrawerLayout) findViewById(R.id.drawer);</span><br><span class="line">ActionBarDrawerToggle toggle=<span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, drawer,toolbar,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">drawer.addDrawerListener(toggle);</span><br><span class="line">toggle.syncState(); <span class="comment">//同步状态 开或关给NavigationView添加监听事件，并重写监听回调</span></span><br><span class="line"></span><br><span class="line">nav.setNavigationItemSelectedListener(<span class="keyword">this</span>);</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123; </span><br><span class="line">        <span class="keyword">case</span> R.id.nav_item_4: <span class="comment">//事件处理</span></span><br><span class="line">             finish();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    drawer.closeDrawer(GravityCompat.START); <span class="comment">//每次点击后关闭抽屉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a><a href="#SnackBar" title="SnackBar"></a>SnackBar</h2><p>这个控件和<code>Toast</code>相似，出现位置是屏幕下方，可以给它添加动作，比如撤销，在CoordinatorLayout中可以配合侧滑删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Snackbar.make(view,<span class="string">“snackbar”</span>,Snackbar.LENGTH_SHORT).setAction(<span class="string">“撤销”</span>, <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            text.setVisibility(View.VISIBLE);</span><br><span class="line">            text.animate().alpha(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;).show();</span><br></pre></td></tr></table></figure><h2 id="CoordinatorLayout"><a href="#CoordinatorLayout" class="headerlink" title="CoordinatorLayout"></a><a href="#CoordinatorLayout" title="CoordinatorLayout"></a>CoordinatorLayout</h2><p>继承自<code>FrameLayout</code>，在没有设置Behavior之前和帧布局无差，通过给它里面的控件设置Behavior可以达到不同的效果。</p></li><li><p><strong>自定义Behavior</strong><br> 一系列的行为监听，当发生什么事情，应该做什么事情。给控件设置Behavior的方式有三种。<br> 1.创建自定义Behavior类继承自系统的Behavior，重写<code>onStartNestedScroll()</code>方法和<code>onNestedPreScroll()</code>方法<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBehavior</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNestedPreScroll(coordinatorLayout, </span><br><span class="line">        <span class="comment">// TODU:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 然后通过控件的LayoutParams设置<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) text.getLayoutParams();</span><br><span class="line">layoutParams.setBehavior(<span class="keyword">new</span> MyBehavior());</span><br></pre></td></tr></table></figure><br>  2.重写Behavior两个参数的构造方法<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在xml布局文件里给相应控件设置上<code>layout_behavior</code>属性    <pre>`app:layout_behavior=&quot;luofeng.study.com.app1.MyBehavior&quot;</pre></p><p>3.第三个方法是在自定义控件时，利用注解框架绑定，参考<code>FloatingActionButton</code></p></li><li><p><strong>AppBarLayout</strong><br>AppBarLayout是对toolbar的在CoordinatorLayout上的外层嵌套，例如下滑隐藏，和悬停提示。如果是只要上滑就显示toolbar，把<code>scrollFlags</code>属性设置为<code>enterAlways</code>，如果要到滑动布局的最顶端再显示，则用<code>enterAlwaysCollapsed</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">app:theme</span>=<span class="string">“@style/ThemeOverlay.AppCompat.Dark.ActionBar”</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">“@+id/toolbar”</span></span><br><span class="line">        <span class="attr">app:layout_scrollFlags</span>=<span class="string">“scroll|enterAlwaysCollapsed”</span>&gt;</span></span><br><span class="line">        android:layout_width=”wrap_content”</span><br><span class="line">        android:layout_height=”?actionBarSize”&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br><span class="line">           </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:text</span>=<span class="string">“悬停条目”</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，因为CoordinatorLayout是帧布局，在设置AppBarLayout后会遮住下面滚动布局的条目，可以通过修改它的<code>layout_behavior</code>属性避免。RecyclerView必须设置LayoutManager才可以使用</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span><br><span class="line">      <span class="attr">android:id</span>=<span class="string">“@+id/rv”</span></span><br><span class="line">      <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">      <span class="attr">android:layout_height</span>=<span class="string">“match_parent”</span></span><br><span class="line">      <span class="attr">app:layoutManager</span>=<span class="string">“LinearLayoutManager”</span></span><br><span class="line">      <span class="attr">app:layout_behavior</span>=<span class="string">“@string/appbar_scrolling_view_behavior”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>CollapsingToolbarLayout</strong><br>可折叠的toolbar，是appbarLayout+toolbar的一种升级版，使用方法是在上面的toolbar上套一层CollapsingToolbarLayout布局，并把scollFlags属性移给它，修改值为exitUntilCollapsed，在下滑隐藏时会保留一个actionbar的位置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">app:contentScrim</span>=<span class="string">“@color/colorPrimary”</span></span><br><span class="line">    <span class="attr">app:layout_scrollFlags</span>=<span class="string">“scroll|exitUntilCollapsed”</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“160dp”</span></span><br><span class="line">        <span class="attr">app:layout_collapseMode</span>=<span class="string">“parallax”</span></span><br><span class="line">        <span class="attr">android:src</span>=<span class="string">“@mipmap/ic_launcher”</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">“@+id/toolbar”</span>  <span class="attr">android:layout_width</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“?actionBarSize”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置的ImageView可以有一个压缩的过程，CollapsingToolbarLayout的<code>app:contentScrim</code>是对压缩后的toolbar的遮蔽处理，通常设置为toolbar原来的颜色，imageview的<code>app:layout_collapseMode</code>属性指定了折叠模式，默认是向上推进，<code>parallax</code>是上下同时压缩。</p></li><li><p><strong>FloatingActionButton</strong><br>浮动按钮，跟ImageButton最大的不同是，它和SnackBar处在同一层，它会因为SnackBar的show而升高，这也是它的名字的来由。它一般放置在AppBar的右下方</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">    <span class="attr">android:id</span>=<span class="string">“@+id/fab”</span></span><br><span class="line">    <span class="attr">app:layout_anchor</span>=<span class="string">“@id/appbar”</span></span><br><span class="line">    <span class="attr">app:layout_anchorGravity</span>=<span class="string">“end|bottom”</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">android:src</span>=<span class="string">“@mipmap/ic_launcher”</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>FloatingActionButton的位置可以随意定，可以修改它的默认Behavior但是，重新设置后会覆盖原来的行为，因此，在使用时尽量去继承自具体的FloatingActionButton的Behavior类。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">    <span class="attr">android:id</span>=<span class="string">“@+id/fab”</span></span><br><span class="line">    <span class="attr">android:layout_gravity</span>=<span class="string">“end|bottom”</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">    <span class="attr">app:layout_behavior</span>=<span class="string">“luofeng.study.com.app1.MyBehavior”</span></span><br><span class="line">    <span class="attr">android:src</span>=<span class="string">“@mipmap/ic_launcher”</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="TextInputLayout"><a href="#TextInputLayout" class="headerlink" title="TextInputLayout"></a><a href="#TextInputLayout" title="TextInputLayout"></a>TextInputLayout</h2><p>文本输入布局，对输入文本有所优化，例如text提示，和基本的输入要求判断提示。使用时对EditText做一层包装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TextInputLayout</span></span><br><span class="line">    <span class="attr">android:id</span>=<span class="string">“@+id/til”</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">“match_parent”</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">“wrap_content”</span></span><br><span class="line">        <span class="attr">android:hint</span>=<span class="string">“用户名”</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过对EditText文本输入的监听，调用TextInputLayout相关方法提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textInput = (TextInputLayout) findViewById(R.id.til);</span><br><span class="line">extInput.getEditText().addTextChangedListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在输入文本时，会有一个错误提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable editable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (editable.length()&lt;<span class="number">6</span>) &#123;</span><br><span class="line">    textInput.setError(<span class="string">“用户名不得少于6位”</span>);</span><br><span class="line">    textInput.setErrorEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         textInput.setErrorEnabled(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Design设计&quot;&gt;&lt;a href=&quot;#Design设计&quot; class=&quot;headerlink&quot; title=&quot;Design设计&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#Design设计&quot; title=&quot;Design设计&quot;&gt;&lt;/a&gt;Design设计&lt;/h1&gt;&lt;p&gt;在开发之前
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.luofeng.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://www.luofeng.com/tags/android/"/>
    
      <category term="笔记" scheme="http://www.luofeng.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="design" scheme="http://www.luofeng.com/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>android-async-http源码分析</title>
    <link href="http://www.luofeng.com/2016/08/25/android-async-http%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.luofeng.com/2016/08/25/android-async-http源码分析/</id>
    <published>2016-08-24T23:02:15.000Z</published>
    <updated>2017-11-25T09:28:56.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-async-http源码分析"><a href="#android-async-http源码分析" class="headerlink" title="android-async-http源码分析"></a><a href="#android-async-http源码分析" title="android-async-http源码分析"></a>android-async-http源码分析</h1><p>今天开始学习android-async-http的源码了</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><a href="#构造方法" title="构造方法"></a>构造方法</h2><p>一共有五种构造方法，前三种都是调用这个有三个参数的，其余三个都是对这三个参数的其中几个或所有做固定赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/<em>*</em></span><br><span class="line"> Creates new AsyncHttpClient using given params</span><br><span class="line"><em></em></span><br><span class="line"> <span class="doctag">@param</span> fixNoHttpResponseException 是否通过忽略ssl认证自动修复连接无响应</span><br><span class="line"><em> <span class="doctag">@param</span> httpPort                   http端口号</em></span><br><span class="line"> <span class="doctag">@param</span> httpsPort                  https端口号</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(<span class="keyword">boolean</span> fixNoHttpResponseException, <span class="keyword">int</span> httpPort, <span class="keyword">int</span> httpsPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这个构造方法也没有具体实现，内部调用的是this(SchemeRegistry schemeRegistry)，getDefaultSchemeRegistry返回一个SchemeRegistry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SchemeRegistry <span class="title">getDefaultSchemeRegistry</span><span class="params">(<span class="keyword">boolean</span> fixNoHttpResponseException, <span class="keyword">int</span> httpPort, <span class="keyword">int</span> httpsPort)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    SchemeRegistry schemeRegistry = <span class="keyword">new</span> SchemeRegistry();</span><br><span class="line">    schemeRegistry.register(<span class="keyword">new</span> Scheme(<span class="string">“http”</span>, PlainSocketFactory.getSocketFactory(), httpPort));</span><br><span class="line">    schemeRegistry.register(<span class="keyword">new</span> Scheme(<span class="string">“https”</span>, sslSocketFactory, httpsPort));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schemeRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实SchemeRegistry就是对这些协议的封装，利用map存了起来，<code>http</code>、<code>https</code>这些协议名称为key，具体的Scheme类就不看了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Scheme <span class="title">register</span><span class="params">(<span class="keyword">final</span> Scheme sch)</span> </span>&#123;</span><br><span class="line">    Args.notNull(sch, <span class="string">“Scheme”</span>);</span><br><span class="line">    <span class="keyword">final</span> Scheme old = registeredSchemes.put(sch.getName(), sch);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后回到构造方法来，内部到底怎么实现的，好长，就是初始化了一些网络请求参数，然后线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(SchemeRegistry schemeRegistry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BasicHttpParams httpParams = <span class="keyword">new</span> BasicHttpParams();  <span class="comment">//默认的http请求参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置httpParams参数的内容</span></span><br><span class="line">    ConnManagerParams.setTimeout(httpParams, connectTimeout);</span><br><span class="line">    ConnManagerParams.setMaxConnectionsPerRoute(httpParams, <span class="keyword">new</span> ConnPerRouteBean(maxConnections));</span><br><span class="line">    ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);</span><br><span class="line"></span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);</span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);</span><br><span class="line">    HttpConnectionParams.setTcpNoDelay(httpParams, <span class="keyword">true</span>);</span><br><span class="line">    HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1); <span class="comment">//协议版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程安全的连接管理者</span></span><br><span class="line">    ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);</span><br><span class="line">    Utils.asserts(cm != <span class="keyword">null</span>, <span class="string">“Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null”</span>);</span><br><span class="line"></span><br><span class="line">    threadPool = getDefaultThreadPool(); <span class="comment">//得到一个线程池对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个请求的map 封装了上下文和该上下文对应的请求的Handler的集合 该Handler用来管理一个请求 比如取消请求</span></span><br><span class="line">    requestMap = Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap&lt;Context, List&lt;RequestHandle&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    clientHeaderMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); <span class="comment">//客户端请求头的一个map</span></span><br><span class="line"></span><br><span class="line">    httpContext = <span class="keyword">new</span> SyncBasicHttpContext(<span class="keyword">new</span> BasicHttpContext());</span><br><span class="line">    <span class="comment">//一个HttpClient对象</span></span><br><span class="line">    httpClient = <span class="keyword">new</span> DefaultHttpClient(cm, httpParams);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一个请求拦截器，给请求Header添加gzip编码，替换重写的某些请求头参数</span></span><br><span class="line">    httpClient.addRequestInterceptor(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpRequest request, HttpContext context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!request.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; <span class="comment">//添加gzip编码</span></span><br><span class="line">                request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String header : clientHeaderMap.keySet()) &#123; <span class="comment">//遍历所有的Header的键</span></span><br><span class="line">                <span class="keyword">if</span> (request.containsHeader(header)) &#123; <span class="comment">//如果请求Header里面包含这个键，就是说有自定义的Header参数</span></span><br><span class="line">                    Header overwritten = request.getFirstHeader(header); <span class="comment">//获得这个Header参数的值</span></span><br><span class="line">                    log.d(LOG_TAG,</span><br><span class="line">                            String.format(<span class="string">“Headers were overwritten! (%s | %s) overwrites (%s | %s)”</span>,</span><br><span class="line">                                    header, clientHeaderMap.get(header),</span><br><span class="line">                                    overwritten.getName(), overwritten.getValue())</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//remove the overwritten header</span></span><br><span class="line">                    request.removeHeader(overwritten); <span class="comment">//移除这个值</span></span><br><span class="line">                &#125;</span><br><span class="line">                request.addHeader(header, clientHeaderMap.get(header)); <span class="comment">//在相应键位上添加clientHeaderMap里的header参数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对响应做拦截，对gzip做解码</span></span><br><span class="line">    httpClient.addResponseInterceptor(<span class="keyword">new</span> HttpResponseInterceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpResponse response, HttpContext context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> HttpEntity entity = response.getEntity(); <span class="comment">//获得内容</span></span><br><span class="line">            <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Header encoding = entity.getContentEncoding(); <span class="comment">//获得编码方式</span></span><br><span class="line">            <span class="keyword">if</span> (encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (HeaderElement element : encoding.getElements()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.getName().equalsIgnoreCase(ENCODING_GZIP)) &#123; <span class="comment">//为gzip编码</span></span><br><span class="line">                        response.setEntity(<span class="keyword">new</span> InflatingEntity(entity)); <span class="comment">//解码之后重新设置内容</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//做认证的，暂时没看，和上面那个唯一不同的是，它排在拦截list的第0位，应该首先处理这个？？</span></span><br><span class="line">    httpClient.addRequestInterceptor(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置重新请求</span></span><br><span class="line">    httpClient.setHttpRequestRetryHandler(<span class="keyword">new</span> RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get、post调用"><a href="#get、post调用" class="headerlink" title="get、post调用"></a><a href="#get、post调用" title="get、post调用"></a>get、post调用</h2><p>在new完对象之后，我们都是直接拿着去调get()、post()方法，下面就去看看，先看get()，一共有6个重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.只有url和响应接口，调用的重载4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(String url, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="keyword">null</span>, url, <span class="keyword">null</span>, responseHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.加上一个params请求参数，调用重载4，经常用这个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(String url, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="keyword">null</span>, url, params, responseHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.没有params，但是多一个context，调用重载4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(context, url, <span class="keyword">null</span>, responseHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.调用sendRequest()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, <span class="keyword">new</span> HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), <span class="keyword">null</span>, responseHandler, context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.设置传入的header再调用sendRequest()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    HttpUriRequest request = <span class="keyword">new</span> HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params));</span><br><span class="line">    <span class="keyword">if</span> (headers != <span class="keyword">null</span>) request.setHeaders(headers);</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, request, <span class="keyword">null</span>, responseHandler,</span><br><span class="line">            context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.use this to send string/json/xml，然后再调用sendRequest()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, addEntityToRequestBase(<span class="keyword">new</span> HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用都是sendRequest()，而且方法是有返回值的，类型是RequestHandler，这个类好像在哪里见过，没错就是这<br>    <code>requestMap = Collections.synchronizedMap(new WeakHashMap&amp;lt;Context, List&amp;lt;RequestHandle&amp;gt;&amp;gt;());</code><br>在AsyncHttpClient的构造方法里，我们创建了这么一个map，里面存着以Context为键泛型为RequestHandler的list集合。再看一眼post方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">post</span><span class="params">(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, addEntityToRequestBase(<span class="keyword">new</span> HttpPost(getURI(url)), entity), contentType, responseHandler, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿，果然和get方法一样，最后都是调用sendRequest()，返回值也都是RequestHandler对象。先看sendRequest()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/<em>*</em></span><br><span class="line">  put一个新请求到线程池的执行队列里</span><br><span class="line"> <em></em></span><br><span class="line">  <span class="doctag">@param</span> client          就是构造方法里初始化的一个DefaultHttpClient</span><br><span class="line"> <em> <span class="doctag">@param</span> contentType     MIME body type，may be null，某些get、put方法里有这个参数</em></span><br><span class="line">  <span class="doctag">@param</span> context         Android上下文，持有这个request请求，为了cancel()</span><br><span class="line"> <em> <span class="doctag">@param</span> httpContext     HttpContext in which the request will be executed</em></span><br><span class="line">  <span class="doctag">@param</span> responseHandler 处理响应的接口</span><br><span class="line"> <em> <span class="doctag">@param</span> uriRequest      必须是HttpUriRequest的实例，封装了url和请求参数等等   </em></span><br><span class="line"> /</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestHandle <span class="title">sendRequest</span><span class="params">(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//uriRequest必须非空</span></span><br><span class="line">    <span class="keyword">if</span> (uriRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">“HttpUriRequest must not be null”</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//responseHandler必须非空</span></span><br><span class="line">    <span class="keyword">if</span> (responseHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">“ResponseHandler must not be null”</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步请求里面不能使用同步响应处理</span></span><br><span class="line">    <span class="keyword">if</span> (responseHandler.getUseSynchronousMode() &amp;&amp; !responseHandler.getUsePoolThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">“Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.”</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置自定义的contentType</span></span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uriRequest <span class="keyword">instanceof</span> HttpEntityEnclosingRequestBase &amp;&amp; ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != <span class="keyword">null</span> &amp;&amp; uriRequest.containsHeader(HEADER_CONTENT_TYPE)) &#123;</span><br><span class="line">            log.w(LOG_TAG, <span class="string">“Passed contentType will be ignored because HttpEntity sets content type”</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确保以上这些都检查完并设置好之后，把uriRequest的一些参数复制给responseHandler一份</span></span><br><span class="line">    responseHandler.setRequestHeaders(uriRequest.getAllHeaders());</span><br><span class="line">    responseHandler.setRequestURI(uriRequest.getURI());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个AsyncHttpRequest对象，把这个对象添加到线程池的执行队列中，创建一个RequestHandler对象</span></span><br><span class="line">    AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);</span><br><span class="line">    threadPool.submit(request);</span><br><span class="line">    RequestHandle requestHandle = <span class="keyword">new</span> RequestHandle(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//context不为空，把上面的requestHandler放到Map中去</span></span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;RequestHandle&gt; requestList;</span><br><span class="line">        <span class="comment">// Add request to request map</span></span><br><span class="line">        <span class="keyword">synchronized</span> (requestMap) &#123;</span><br><span class="line">            requestList = requestMap.get(context);</span><br><span class="line">            <span class="keyword">if</span> (requestList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestList = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;RequestHandle&gt;());</span><br><span class="line">                requestMap.put(context, requestList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestList.add(requestHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合，如果发现有requestHandler对应的request已经消费完，则移除当前requestHandler</span></span><br><span class="line">        Iterator&lt;RequestHandle&gt; iterator = requestList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iterator.next().shouldBeGarbageCollected()) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestHandle; <span class="comment">//返回requestHandle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里知道我们所有的请求最后都被封装到了AsyncHttpRequest，然后把它交给了线程池，然后再处理了下RequestHandler，并返回，下面看看这个RequestHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;AsyncHttpRequest&gt; request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandle</span><span class="params">(AsyncHttpRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = <span class="keyword">new</span> WeakReference&lt;AsyncHttpRequest&gt;(request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于取消当前request，就算返回true也并不一定是真的取消成功了，只是尝试去取消</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsyncHttpRequest _request = request.get();</span><br><span class="line">        <span class="keyword">if</span> (_request != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        _request.cancel(mayInterruptIfRunning);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> _request.cancel(mayInterruptIfRunning);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前request被取消了或者完成了，则把当前request对象=null，不是引用，而是里面包裹的AsyncHttpRequest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBeGarbageCollected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> should = isCancelled() || isFinished();</span><br><span class="line">        <span class="keyword">if</span> (should)</span><br><span class="line">            request.clear();</span><br><span class="line">        <span class="keyword">return</span> should;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它持有一个AsyncHttpRequest对象，这个是在构造方法里面传入的，并且通过弱引用包裹，与上面的sendRequest()方法结合起来就是，在我们调用get()、post()方法发送请求时，它会把我们的一系列请求参数封装，作为一个Request对象扔给了线程池的待执行队列，然后创建一个持有当前Request对象的RequestHandler，并返回给调用者。请求的步骤大概就是这样。</p><h2 id="开始异步请求"><a href="#开始异步请求" class="headerlink" title="开始异步请求"></a><a href="#开始异步请求" title="开始异步请求"></a>开始异步请求</h2><p>首先，AsyncHttpRequest实现了Runnable接口，现在先看看构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpRequest</span><span class="params">(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = Utils.notNull(client, <span class="string">“client”</span>);</span><br><span class="line">    <span class="keyword">this</span>.context = Utils.notNull(context, <span class="string">“context”</span>);</span><br><span class="line">    <span class="keyword">this</span>.request = Utils.notNull(request, <span class="string">“request”</span>);</span><br><span class="line">    <span class="keyword">this</span>.responseHandler = Utils.notNull(responseHandler, <span class="string">“responseHandler”</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是判断了一下参数是否为空然后赋值，下面就去看它的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否取消了，取消则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该Request是否已经准备执行，避免多次执行请求</span></span><br><span class="line">    <span class="keyword">if</span> (!isRequestPreProcessed) &#123;</span><br><span class="line">        isRequestPreProcessed = <span class="keyword">true</span>;</span><br><span class="line">        onPreProcessRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给调用者发送一个准备开始的消息</span></span><br><span class="line">    responseHandler.sendStartMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//开始请求并尝试重新请求</span></span><br><span class="line">        makeRequestWithRetries();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            <span class="comment">//没有被取消就发送错误消息</span></span><br><span class="line">            responseHandler.sendFailureMessage(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AsyncHttpClient.log.e(<span class="string">“AsyncHttpRequest”</span>, <span class="string">“makeRequestWithRetries returned error”</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送完成消息</span></span><br><span class="line">    responseHandler.sendFinishMessage();</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置完成状态</span></span><br><span class="line">    isFinished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始请求前给调用者发送了一个开始的消息，然后开始请求，如果请求出错，发送了一个错误的消息，完成后也发送了一个完成的消息，这是整个流程，下面来看看，它是怎么请求的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRequestWithRetries</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//在AsyncHttpClient的构造方法里我们设置了这么一个东东</span></span><br><span class="line">    HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (retry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makeRequest(); <span class="comment">//终于要发送请求了吗</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            …各种捕获异常，抛异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像还是没有开始请求，接着往里面看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做了下判断，更新Header</span></span><br><span class="line">    <span class="keyword">if</span> (responseHandler <span class="keyword">instanceof</span> RangeFileAsyncHttpResponseHandler) &#123;</span><br><span class="line">        ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正的请求在这里</span></span><br><span class="line">    HttpResponse response = client.execute(request, context);</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送了一个处理的消息</span></span><br><span class="line">    responseHandler.sendResponseMessage(response);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的请求开始了，虽然还没见着方法体，可以看到这里根据传入的responseHandler的不同，要做一个响应Header的处理，然后开始请求，然后把返回的response交给responseHandler做响应处理，怎么处理等会儿再看，把request看完先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span><br><span class="line">        <span class="keyword">final</span> HttpUriRequest request,</span><br><span class="line">        <span class="keyword">final</span> HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException </span>&#123;</span><br><span class="line">    Args.notNull(request, <span class="string">“HTTP request”</span>);</span><br><span class="line">    <span class="keyword">return</span> doExecute(determineTarget(request), request, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个execute是CloseableHttpClient的方法，我们传入的client是它的子类的一个实例，它又调用了doExecute()方法，继续看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> CloseableHttpResponse <span class="title">doExecute</span><span class="params">(HttpHost target, HttpRequest request,</span><br><span class="line">        HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException</span>;</span><br></pre></td></tr></table></figure><p>果然，这是一个抽象类，到底怎么doExecute交给具体的子类实现，下面去找它的实现，在AbstractHttpClient里面找到了这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     out = CloseableHttpResponseProxy.newProxy(</span><br><span class="line">     director.execute(target, request, execContext));</span><br><span class="line">    &#125; <span class="keyword">catch</span> …</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> out;</span><br></pre></td></tr></table></figure><p>不知道我费劲心思想找这个发送请求的方法干嘛，它又转移了，偷偷瞄了一眼这个execute方法，好长，吓得我赶紧退了回来，具体的怎么请求其实不需要太了解，反正也看不懂，就是一系列封装，最后返回这个out，也就是请求网络完成后的响应，</p><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a><a href="#响应处理" title="响应处理"></a>响应处理</h2><p>现在就来看处理响应的ResponseHandler了<br>    <code>中间代码不贴了</code><br>ResponseHandler其实是一个接口，封装了响应之后各个阶段的方法，而且框架已经帮我们写了很多实现类，比如常用的AsyncHttpResponseHandler、DataAsyncHttpResponseHandler、TextHttpResponseHandler、JsonHttpResponseHandler、FileAsyncHttpResponseHandler，所以用不着我们自己去实现，针对每种不同的请求方式，这些类会自动做相关的处理，比如请求获得一个文件，会在处理response的时候，直接返回一个file对象，下面来看看AsyncHttpResponseHandler，它是其它几个常用实现类的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.不带参数，一般我们get、post时候就是用这个，匿名对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpResponseHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.第一个构造方法其实就是调用的这个，然后调用第4个构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpResponseHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认使用主线程的Looper</span></span><br><span class="line">    <span class="keyword">this</span>(looper == <span class="keyword">null</span> ? Looper.myLooper() : looper, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.可以手动指定使用线程池所在线程？不一定对，应该是当前Request所在的线程，即同步响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpResponseHandler</span><span class="params">(<span class="keyword">boolean</span> usePoolThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(usePoolThread ? <span class="keyword">null</span> : Looper.myLooper(), usePoolThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.其它构造方法都是调用这个，而这个构造方法是private的</span></span><br><span class="line"><span class="comment">// 如果同步响应，loop必须为空，异步响应，loop必须是Looper.myLooper()，而且usePoolThread必定为false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AsyncHttpResponseHandler</span><span class="params">(Looper looper, <span class="keyword">boolean</span> usePoolThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!usePoolThread) &#123;</span><br><span class="line">        <span class="comment">// 异步响应时，初始化了handler对象</span></span><br><span class="line">        Utils.asserts(looper != <span class="keyword">null</span>, <span class="string">“use looper thread, must call Looper.prepare() first!”</span>);</span><br><span class="line">        <span class="keyword">this</span>.looper = looper;</span><br><span class="line">        <span class="keyword">this</span>.handler = <span class="keyword">new</span> ResponderHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果同步响应，全部置空</span></span><br><span class="line">        Utils.asserts(looper == <span class="keyword">null</span>, <span class="string">“use pool thread, looper should be null!”</span>);</span><br><span class="line">        <span class="keyword">this</span>.looper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.handler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.usePoolThread = usePoolThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面初始化Handler的时候，发现是new了一个ResponderHandler对象，下面去看看它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/<em>*</em></span><br><span class="line">  Avoid leaks by using a non-anonymous handler class.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponderHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpResponseHandler mResponder;</span><br><span class="line"></span><br><span class="line">    ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.mResponder = mResponder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        mResponder.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看它的注释，通过使用一个非匿名的Handler类来避免泄漏，唉，看别人写的代码就是享受呀，静态内部类，学到了。再看它的实现，把handleMessage方法交给外面的AsyncHttpResponseHandler去处理，下面看看怎么处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Methods which emulate android’s Handler and Message methods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    Object[] response;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 根据收到的消息，调用相关的回调</span></span><br><span class="line">        <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> SUCCESS_MESSAGE:</span><br><span class="line">                response = (Object[]) message.obj;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; response.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    onSuccess((Integer) response[<span class="number">0</span>], (Header[]) response[<span class="number">1</span>], (<span class="keyword">byte</span>[]) response[<span class="number">2</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AsyncHttpClient.log.e(LOG_TAG, <span class="string">“SUCCESS_MESSAGE didn’t got enough params”</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FAILURE_MESSAGE:</span><br><span class="line">                response = (Object[]) message.obj;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; response.length &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                    onFailure((Integer) response[<span class="number">0</span>], (Header[]) response[<span class="number">1</span>], (<span class="keyword">byte</span>[]) response[<span class="number">2</span>], (Throwable) response[<span class="number">3</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AsyncHttpClient.log.e(LOG_TAG, <span class="string">“FAILURE_MESSAGE didn’t got enough params”</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> START_MESSAGE:</span><br><span class="line">                onStart();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINISH_MESSAGE:</span><br><span class="line">                onFinish();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROGRESS_MESSAGE:</span><br><span class="line">                response = (Object[]) message.obj;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; response.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        onProgress((Long) response[<span class="number">0</span>], (Long) response[<span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        AsyncHttpClient.log.e(LOG_TAG, <span class="string">“custom onProgress contains an error”</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AsyncHttpClient.log.e(LOG_TAG, <span class="string">“PROGRESS_MESSAGE didn’t got enough params”</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RETRY_MESSAGE:</span><br><span class="line">                response = (Object[]) message.obj;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; response.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    onRetry((Integer) response[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AsyncHttpClient.log.e(LOG_TAG, <span class="string">“RETRY_MESSAGE didn’t get enough params”</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CANCEL_MESSAGE:</span><br><span class="line">                onCancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">        onUserException(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一句的注释意思是，我就模仿Android的Handler来处理消息，根据发送消息的what判断，去调用相关的回调，从start到finish()全部都有，这些消息在什么时候发的呢，在开始的sendRequest的一系列过程中都有所体现，success和failure的消息稍微有点隐晦，是在sendResponseMessage方法中处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendResponseMessage</span><span class="params">(HttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果请求被cancel掉了就不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        StatusLine status = response.getStatusLine();</span><br><span class="line">        <span class="keyword">byte</span>[] responseBody;</span><br><span class="line">        responseBody = getResponseData(response.getEntity());</span><br><span class="line">        <span class="keyword">if</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status.getStatusCode() &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">                sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, <span class="keyword">new</span> HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>responseBody从getResponseData()方法中得到，根据响应码的值判断是否成功，发送相应的消息出去，至此为止好像还有一个回调没有发消息，onProgress()，下面来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getResponseData(HttpEntity entity) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] responseBody = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream instream = entity.getContent();</span><br><span class="line">        <span class="keyword">if</span> (instream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> contentLength = entity.getContentLength(); <span class="comment">//获得响应内容的长度</span></span><br><span class="line">            <span class="keyword">if</span> (contentLength &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">“HTTP entity too large to be buffered in memory”</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> buffersize = (contentLength &lt;= <span class="number">0</span>) ? BUFFER_SIZE : (<span class="keyword">int</span>) contentLength;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteArrayBuffer buffer = <span class="keyword">new</span> ByteArrayBuffer(buffersize);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">                    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> l;</span><br><span class="line">                    <span class="keyword">while</span> ((l = instream.read(tmp)) != -<span class="number">1</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        count += l;</span><br><span class="line">                        buffer.append(tmp, <span class="number">0</span>, l);</span><br><span class="line">                        sendProgressMessage(count, (contentLength &lt;= <span class="number">0</span> ? <span class="number">1</span> : contentLength));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    AsyncHttpClient.silentCloseInputStream(instream);</span><br><span class="line">                    AsyncHttpClient.endEntityViaReflection(entity);</span><br><span class="line">                &#125;</span><br><span class="line">                responseBody = buffer.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">“File too large to fit into available memory”</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseBody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendProgressMessage()在while循环里调用了，循环条件中加了一个是否cancel，如果被取消就没必要再发消息了，finally里面关流，并且把响应内容toByteArray()返回，那么异步响应到此为止全部结束，下面看看同步响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUseSynchronousMode</span><span class="params">(<span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A looper must be prepared before setting asynchronous mode.</span></span><br><span class="line">    <span class="keyword">if</span> (!sync &amp;&amp; looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sync = <span class="keyword">true</span>;</span><br><span class="line">        AsyncHttpClient.log.w(LOG_TAG, <span class="string">“Current thread has not called Looper.prepare(). Forcing synchronous mode.”</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If using asynchronous mode.</span></span><br><span class="line">    <span class="keyword">if</span> (!sync &amp;&amp; handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create a handler on current thread to submit tasks</span></span><br><span class="line">        handler = <span class="keyword">new</span> ResponderHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sync &amp;&amp; handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Consider adding a flag to remove all queued messages.</span></span><br><span class="line">        handler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useSynchronousMode = sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync的值是设置进来的，假设为false，那么就是说我希望是异步响应，然而你的looper为空，所以不可能异步，就强制设置回true。其实想想，looper什么情况下可能为null，那就是在构造方法里传入usePoolThread为true的时候，也就是说刚好也设为同步。如果传入的是true，那就没话说，最后也把mod设置为同步。那么同步mod下怎么处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getUseSynchronousMode() || handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// do not send messages if request has been cancelled</span></span><br><span class="line">        Utils.asserts(handler != <span class="keyword">null</span>, <span class="string">“handler should not be null!”</span>);</span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿，只能说设计得太巧妙了，如果是同步模式下，直接处理消息，异步模式才会用handler去发消息，该回调还是回调，但是同步模式下，不能直接更新ui，切记</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a><a href="#总结一下" title="总结一下"></a>总结一下</h2><p>AsyncHttpClient核心类<br>AsyncHttpRequest+RequestHandler请求和请求管理<br>ResponseHandler+子类实现+setMod可以同步/异步响应<br>技术要点：  </p><ul><li>线程池，AsyncHttpRequest实现Runnable接口，添加到线程池执行队列中<em>   AsyncResponseHandler的异步响应，运用了android中的Handler</em>   ResponseHandler是一个接口，针对接口编程，扩展性更强</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-async-http源码分析&quot;&gt;&lt;a href=&quot;#android-async-http源码分析&quot; class=&quot;headerlink&quot; title=&quot;android-async-http源码分析&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#android-as
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.luofeng.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://www.luofeng.com/tags/android/"/>
    
      <category term="笔记" scheme="http://www.luofeng.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="http://www.luofeng.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>瞎子</title>
    <link href="http://www.luofeng.com/2016/08/13/%E7%9E%8E%E5%AD%90/"/>
    <id>http://www.luofeng.com/2016/08/13/瞎子/</id>
    <published>2016-08-12T22:21:01.000Z</published>
    <updated>2017-11-25T09:27:38.609Z</updated>
    
    <content type="html"><![CDATA[<p>下午四点二十八分的时候，我接了一个电话，在此之前，我漠视了许多通同一区号的号码，我不知道我接它的理由，只听到聚氯乙烯包裹下的性感女声：<br>“先生，马上要七夕了，你要带着黑眼圈见女朋友吗？”<br>听这口吻，我立马知道对方是为推销护眼类药物而来，像是突然没了什么顾虑般，点开了通话扬声器，一边带着戏谑的语气道。<br>“首先你得有一个女朋友”<br>我的声音很快从四周传递回来，这样的语气，在流火的七月里无疑是一阵清凉。<br>“那你想要带着黑眼圈找女朋友吗？”<br>听筒那边很快传来回复。<br>这女人想卖产品想疯了，白费我一番戏谑的心思。我微微皱眉<br>“我对你要推销的产品一点兴趣也没有”<br>过了几秒又悠然道，<br>“推销产品时你应该先说出一些令人困扰的现状，让你的听众能够在这些困扰中找到认同感，然后告诉他们可能改善的方法，最后引出你要卖的东西。”<br>“你会买吗？”好像怕我没理解，那头又补充道，“如果按你那样说，你会买吗？”<br>“不会”，我说的很快，我很想在她解释之前说完，我生怕她觉得我是那种需要听解释才能懂的人。<br>“你刚才说了什么？”<br>“我说不会，我是那种怎么看电视怎么熬夜眼睛都不会坏的人。”<br>不得不说我确实有双好眼睛，讲这句话的时候我甚至有种自豪感。<br>“你说话真有趣，你也是做微商么”<br>“不是”，然后有点炫耀地说道，“我是个程序员”<br>“嗯？程序员？经常看电脑吧？是不是经常眼睛觉得疲劳？”开始那种性感的声音此时已经蜕变得冷静。<br>“对，偶尔会酸酸的。。。”还没说完，那边响起丝丝笑声，而后又平静下来。<br>“是不是脑袋也会嗡嗡响，太阳穴也会疼，你应该时不时站起来活动下，看看远处，洗把脸。”她顿了顿，好像在水里憋了好久的气。“我最近看到一款对眼睛很好的产品”，她是笑着说这句话的，笑得很大声。<br>我必须得承认这个女子的聪明，有时候我也像她一样。然而此刻我没有说话，一直沉静着。<br>她似乎察觉到自己的失态，于是赶忙停住笑声，这种戛然而止，无异于从一匹纯种白猫身上硬生生长出一撮黑毛。只见那只猫的嘴又动了。<br>“你做程序员一个月多少钱？”<br>我没有仔细去辩证她的问题是否转变得过于突兀，只是支吾道，<br>“嗯…六千、或者七千、大概有八千吧。”我忘了我只是想做一个程序员，到目前为止，并不是。<br>听到这个，那张脸好像又变了，无线电波中都带着嘲讽的意味，<br>“我们做微商一个月随随便便上万，听你说话对销售还颇有天赋，不如加入我们吧。”<br>“其实我并没有什么销售天赋，我就是站在对方的角度想问题，对了，你们除了卖护眼类的还有什么其它的么？”<br>“那你需要什么呢”，她立马回答，这就是一个商人的惯性，就像“can i help you”类的蠢话。<br>“永远保留客户选择的权利，永远不要让自己扎进死胡同。我随便说一个你们没有的东西，你就接不了话了。”我很神气地回她，好像出了口程序员工资没她高的恶气。<br>她好像并未因此气馁，她的声音甜得近乎暧昧，“像你这样的人才不做微商真是可惜了。”<br>“我不喜欢微商，我讨厌销售。”我喊起来。<br>挂掉电话，回音还在继续，我从没仔细听过自己的音色，此时，觉得跟夜深人静处的狗吠很像。<br>我是个瞎子，干嘛要买护眼产品，而一个瞎子，难道能做销售吗？<br>一个月前，我开始有变成瞎子的动向，这些，都是在很久之后才觉悟到。一开始的时候，只是晚一点去食堂吃饭，后来演变成躲在角落吃饭，再后来是打饭都塞着耳机，前几日已经要戴着帽子才敢去食堂了。这一过程中我慢慢出现幻觉，也会幻听，夜了也不开灯，喜欢躺着，看大量的故事，却懒得动笔。至此为止，我都没变成一个瞎子。<br>然而昨天的那场面试，却把我死死打入瞎子的地狱。<br>这个月来，我陆陆续续参加过许多场面试，大多数无疾而终。我以为，这次也一样。<br>从电梯上走出来的时候，旁边是群谈论高级历史的年轻烟民，“秦始皇上六代分别叫什么名字”，这个声音来自一名穿棕色仿牛皮人字拖、脱水的半截海蓝牛仔裤的亢奋男子，他脸型偏瘦，脸色像极了吸水后的焦黄烟蒂，原本应该呈现的自然忧虑的眉目，此刻毅然舒展开，与他嘴角的一丝弧度交相呼应。我很快走过他们，我自诩博览群书却回答不出他的问题，只知道答案中有个嬴字。面试公司就在转弯的第一处入口，一扇玻璃门半掩着，正对门是一堵冰淇淋色的隔墙，上面彩绘着xx科技有限公司几个大字，门的左边摆一张纵向的咖啡木案，除了几封松弛的蓝底文件夹，其上再无他物。那堵墙的右边，也就是这半掩着的门的后面，应该就是真正的办公地点，只是此刻隔着不全透明的玻璃望去，却有几分像犹抱琵琶的歌女。<br>推门进去之后，便看到琵琶遮住的全貌，木案的前方，是张小巧的圆形桌子，颜色呈深黑，之间夹杂一些淡雅的不规则浮纹，边缘被精心打磨过，人影经掠处，显现出一种复古的贵金属光晕。桌子向后三米，就到了真的办公区，地面沿那堵横墙分开，往下，要低一个门槛的高度，那里是踏踏实实的水泥地，与这边的青花瓷砖相比，破落的像是三流城镇里的年修国道。在那之上，摆放着两排背向的电脑，在我目光流转下迅速向两旁排列开去。<br>“我是过来面试的”，我边说边朝前台走。<br>前台是只很温顺的妹子，她指了指我身后的圆桌，“先坐会儿吧。”<br>我回头看了一眼，就是刚刚看到的那张桌子，那儿正坐着三个人，三名女性。她们低着头在写些什么。我没说话，只是安静地向外走去。<br>左边走廊的尽头传来断续的女子对话，时而嬉笑，时而哀叹，我能猜到她们是时尚的妙龄女郎，还有一个摄影师，她们丝毫不为自己的美丽感到担忧，游离在光与影的稍纵即逝里。<br>我来回踱步，或是低头沉思，或是徒对天花，偶尔停下在墙壁上画上几笔抽象的名迹，一边还用余光瞄两眼门后的三人小圆桌。约莫过了六七分钟，出来一个接电话的男子，声音很浑厚，方言也听不懂，语气倒是比之前的电梯烟民俏皮些，我未及仔细看清他的样子，便顺着他拉开的门缝钻进去了。<br>桌子边上只留下一个人，头发染成橙红色，落在肩上的发梢翘起微卷的尾巴，我移步桌子，坐在离她150度角的饮水机的斜前方。前台妹子见我过来就让填了信息表，顺带帮我们两个人到了一杯水，橙红色女郎显得有些讶异，抬起头的时候连忙说了声谢谢。<br>很快，桌子边只剩我了，那女子被带进去的时候喝了口水，我听说人紧张的时候喉咙就会变得很干，所以她喝之后没多久我也喝了，不过是自己带的水，我以为，只要不喝别人的水，就不用说谢谢。<br>开始有很多人走动，很多人来我身后的饮水机装水，出去接电话的男子也回来了，甚至那群电梯烟民也进来了，跟着进来的还有一名无害的龅牙妹。我惶恐于那群烟民同属这家公司，我深怕成为这提出“秦始皇上六代叫什么名字”的高级学问的文化人的同僚。然而令人庆幸的是，那个无害的龅牙妹依然无所适从的笑着，她作为一个同我一样的求职者，好像对此习以为常。<br>她对着身份证填个人信息，从百度文库偌大的自然段中寻找自己的优缺点，我不禁笑出来，好像听到这个世上最好笑的笑话。<br>在我进入面试之前，有个手拿相机的男子冲进来，一小会又急匆匆的跑出去，这样的画面，在我跟hr聊的时候一直闪现着，究竟是什么使得他这样紧迫呢。有那么一瞬间，我看到龅牙妹和另一名女性面对着坐在沙发上，她们一样无害，一样笑容可掬。也是在那一瞬间，又变得模糊，好像她们并没有出现过。<br>聊以慰藉的交谈总让人寂寞，我就一直接受着来自寂寞的字眼，无论多么喋喋不休。我的心，早已随着18层高楼下小的可怜的汽车引擎逃离。<br>出去的时候，那些看电影的人依然在看电影，玩游戏的依然在玩游戏，聊天的依然在聊天，我同前台的妹子挥手告别，推开门的瞬间，室内节能灯在茶色地板上投下巨大的黑影。<br>我不知道所谓瞎子的定义，我把自己关在柜子里，四周一片黑暗。微弱的回音从黑暗中荡开去，然而没有人听到，那是手机铃声。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下午四点二十八分的时候，我接了一个电话，在此之前，我漠视了许多通同一区号的号码，我不知道我接它的理由，只听到聚氯乙烯包裹下的性感女声：&lt;br&gt;“先生，马上要七夕了，你要带着黑眼圈见女朋友吗？”&lt;br&gt;听这口吻，我立马知道对方是为推销护眼类药物而来，像是突然没了什么顾虑般，点
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>由零开始</title>
    <link href="http://www.luofeng.com/2016/07/24/%E7%94%B1%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    <id>http://www.luofeng.com/2016/07/24/由零开始/</id>
    <published>2016-07-24T10:56:14.000Z</published>
    <updated>2017-11-25T09:27:31.778Z</updated>
    
    <content type="html"><![CDATA[<p>从凌晨一刻开始，我已经整整四个钟头没写一句话，洗手台下面的水管一直漏水，昨天我就发现了，也可能是前天，水就这么稀里里地流，我能想象它把房间充满，湿漉漉的被子死死压在身上，重得像这茫茫夜色的寂静，然而，除了夜什么也没发生。此时，房间另一边传来吱呀吱呀的声音，是突然侧身的室友，我急忙把手机屏亮起来，紧接着去床底下摸索出一盘蚊香，我想只有点上什么才能够逃脱，即使连一只蚊子也没有。</p><p>早上大概九点钟醒，一夜难眠，此刻兴致反倒高昂得紧，好像终于要开始什么伟大的事，毫不夸张地说，这股精神劲还是有生以来头一次。一切准备妥当，再去洗手台刮胡子，抹上一点肥皂水，尽量均匀些，不锈钢刀片沿上颚下巴来回律动着，欢快的节奏，如同远古深山里叮咚的清泉，不消尝一口，便已醉如泥泞。仿佛为了印证上述功效，室友一脸朦胧，以一个侧身盲点的位置伸手往床下探，约莫从他的鞋上晃三五次以后，我才恍然记起，他是在找袜子。十分钟前，我把房间重新整理了下，他的袜子作为房里最脏的东西之一，自然不能幸免，你可以想象得出，袜子是以怎样的痕迹从我手中落入垃圾娄，它简直是这个世界上最完美的抛物线，袜子对它饰演了这一杰作表示非常荣幸，所以正自鸣得意地待在垃圾娄的最底部。室友已经坐起来了，他蹙眉凝视，我想他已经很清楚了，他一直引以为傲的袜子，不存在了，但我没有因此同情他，反而我认为他表情转变得太过粗鲁，毕竟他只是为了印证功效才出现的。先不言他，此时我已经把胡子刮得一干二净，老实说，镜子里的这幅尊容比昨天不止漂亮上十倍，我讲这话的意思不是说昨天因为我外貌差了零点零一分而拒绝我的女孩今天就会接受我，我只是想陈述某件事实——我要出去面试了，因为零的倍数只可能是零，我始终不能靠脸吃饭。出门的时候，室友提醒我把垃圾也顺带扔了，我努了努嘴始终没有说话，我想，让一个人自己放弃一样东西很难，不如由他人代劳。   </p><p>夏季的水泥路显然有些烫脚，我不得不以一个可笑的袋鼠跳的方式从树荫间穿过，原本并非一定要这样走，然而三食堂重新装修，这使得我必须再去找新的吃饭的地方，那儿步行的话将近有十分钟的路程。我想起两个月后到任的新承包商，他是原先二楼卖手抓饼的老板，对这个男人，并没多深刻的印象，看起来务实，矜矜业业。但很赏识老板娘，长相清秀，手艺精湛，会因为加了我不喜欢的香菜而重新做过，看得出来，她对她所从事职业的热爱，所以当我听说是她要承包整个食堂的时候，我第一个念头是，以后每个窗口都卖手抓饼。正是抱着这样的念头，我来到了正常营业的一食堂的门口。  </p><p>里面人声鼎沸，只在门外，仿佛便有一种要被吞没的压迫感，各式各样的佐料味、汗味、本地产的廉价啤酒味、以及看起来格格不入的时尚女郎身上抹的香水味，它们像散发的彩虹的某一色光，在1q84小小人的带领下彼此厮杀着，然而又不能完全消灭，我看在眼里，却并未因此却步，再残酷也都要进去，都要吃饭。  </p><p>等我打饭回来，并没直接去平时坐的座位，至于原因，那又是另一件事了。今天吃饭吃得比平时早了很多，虽然在时间上来说也不算早，但从我的生物钟看，它早得近乎异常。你要知道，这世上还有另一种人，他们享受孤独，只在人少的时候出没，像夜行的猫头鹰，敏锐、附有想象空间、又独具一格。我朝平日坐的位置看了两眼，然后选了它对面下一排的桌子，我就这样一边吃饭一边审视着对面那个座位。她妆容清秀，长头发，白色衬衣，没有破洞的蓝色牛仔裤，不过时的白底简约系带凉鞋，但是没有高跟，按鲁迅先生的原话，应该说标致极了，她安然霸占了我吃饭的宝地，以一种比我优雅多了的吃相被我审视着，我想，她究竟是迫于什么非要选择的这个位置。</p><p>要么她是同我一样类型的人物，首先不得不说那个位置在地理上已是绝佳——靠墙的一角，偏偏它对面的座位上还放着一顶迷彩军帽，不管出于什么，一般人都很难盯上这里，就连我，也是在连续使用洞察之眼的几回合后，才明白它正是为我这样注定成为王者的人而存在。所以当我第一次端着碗走向它的时候，我颤颤巍巍看了好久，从整个椅子的结构，到涂漆色泽，到颜料均匀度，连焊接口锈斑的小小瑕疵，都像是量身打造，无一不令人满意。我用手轻轻地去碰它，只在那一刹那，我发誓我被电到了，就像第一次牵心仪姑娘的手那样，电流从手的一端流经全身最后传到拿碗的那只手，在电流到达手指的零点零一秒内，我把碗筷放到了桌上，与其说放，不如说掉，我深怕因此而出名，这对于一个即将成为王者的人来说，是耻辱。碗筷放好，我把一只脚穿过桌子的承重架，另一只脚落在架子上，整个胯部被拉开一高一低，这样的姿势，让我有股学某种动物留下标志的冲动。考虑了约莫两分钟，才作罢，谁能凭爱意要富士山私有。当我马上就要找到什么词来形容我当时是如何把另一只脚放下的时候，不远处传来了玻璃酒瓶碎掉的声音。</p><p>不知你有没有遇过，因为你即将完成一件伟大的事，它看起来很近，却总是困难重重，我把这类事情归于命运的嫉妒。玻璃酒瓶碎了很明显属于此，《盗梦空间》里把音乐声当作梦醒的标志，它本身并不能唤醒任何人，它只是通知所有人你应该醒了。所以下一秒钟，我看到了令我排除以上假设——女孩与我同一类人的一幕。她略带惊恐地看向声源地，脚不自觉改变了所朝的方向，可能的话，她应该已经身处数米之外了。她是个爱看热闹的人，我马上下了如此的定论，这并非一只猫头鹰应禀有的天赋，它不过一场酒味小小人请求援军的闹剧。为此我只好重新思考有关她坐在那个位置的罪证。</p><p>曾经看过这么一部电影，女孩在恋人去世之后仍保持他存在着的记忆，比如，经常到小区附近的西餐厅点两份同样的意大利面，然而只吃一份；经常去学士路尽头的照相馆洗两份同样的生活照，却只拿走一份；经常从路过的某个未知名的零售店买两份同样的冰淇淋，而看着另一份融化。我一面否定女孩的行为，一面羡慕她的命运，她以一种近乎病态的爱来证明人们对于浪漫盲目般的憧憬，让每一代的俊男靓女前赴后继地追逐这个概率，满足一个情怀，或者寻找一种解脱。不管是什么，此时此刻，我已然把这顶帽子结结实实扣到眼前姑娘头上，是从她对面座位上拿的隶属于她已逝去恋人的帽子，她必须是这样的人，别无可能。吃完饭后，我悄然离开，我早该离开，甚至不该进来。  </p><p>食堂前被赶出来的老头木箱里的啤酒只剩下几瓶，我看着从酒瓶瓶颈往下流的液化水汽，感觉天更热了。</p><p>原本想抄小路过桥快速到达公车站，途经清心亭的时候却被半个河面的莲花吸引，于是驻足拍了张照。我想起几日前从外面试回来时，有人问过荷花池在什么地方，当时含糊此处并无荷花云云，此刻见河中接天莲叶别样红，不禁抹了抹额角的细汗，一边还要骂上几句太阳的狠话。</p><p>过了李冰父子像就到了桥上，前面是干净的没有半根水草的河面，反倒是河沿的两侧满是半人高的芦苇，风沿着河面吹来，在芦苇倾斜间形成一股刺脸的热浪，而就在这一动一静之间，我看到不远处一个年轻的充满活力的垂钓者，之所以这么形容，是出于其对垂钓时间的把握，现在正是晌午，又哪里来的不怕热的鱼。转念一想，既然此刻有人站在这里看他钓，那这渔人也并非没有钓到鱼的可能，姜太公直钩尚且钓到周文王，就好像右边这十里荷花，没有开的时候，又有谁知道它的存在呢？    </p><p>一点二十二分下车，离约好面试的时间差三十八分钟，我没有直接去面试地点等，而是待在下车那个站台的后面的草坪一侧看书，看的是菲茨杰拉德的《人间天堂》,一直到一点五十四再去的面试处，期间公路的另一侧修剪草坪，这种大自然泥草的清新味道，只在原来割稻谷的时候闻到，而现在应该就是收割稻谷的时令了。我一边惶恐于自己的衣食无忧，一边没入林立的高楼大厦。   </p><p>面试我的是个称得上漂亮的女人，面目清秀，身材匀称，头发整齐地落在肩上，流行的空气刘海因为长长有点黏住额角，言辞犀利，讲话时右手会把左手的食指握住，中指戴着一颗有点胖的金色转运珠，在手部的细微动作下格外引人注目。陆小凤说漂亮的女人最可怕，眼前的这位无疑就是一个，我们谈论了将近三个小时，之间我很怕因为她精湛的职场分析和层级的利诱技巧而改变来时的决议，索性我告诉她了，我只是想把最后一份简历送出去，我跟你们公司没什么仇，但我跟他们是两种人，而我不想变成他们。面试完毕后又聊了会儿，纯粹是消磨时光，听别人的故事，然后羡慕、嫉妒、或者同情，其实没什么两样，你依旧是这高级建材间的跳梁小丑，依旧做好本该悲哀者的觉悟。 </p><p>一直拖到他们公司开会才离开，坐电梯下楼时差点从中途又出去，好在被人叫回来。沿公路外侧的人形道往回走，在第一个路口的支路向右转，我数着对面交通信号灯的秒数，整了整因为重新出汗而黏在背部的棉质衬衫。此时，太阳已经西沉，公交站的金属路牌上反射出季节的余热。  </p><p>夜色降临的时候，我人在足球场地跑道上，我不知道跑了多少圈，只知道还没有虚脱。王小波说他总是不让自己闲起来，实在闲的时候就去外面跑步，这能有效避免手淫，我不排除这一功效，我跑步的原因是让自己虚脱，它能有效避免一切，包括思考。但是现在，显然没有达到这一效果。回来的时候，我点了一支烟，烟是六月中旬买的，芙蓉王，原本打算给投靠的同学抽，后来没有去，就一直留在书包里，已经将近一个月，烟只少了十分之一。我是个讨厌烟味的人，我告诉面试我的那个漂亮女人，我跟她解释，我讨厌的是那种吸入的烟的味道，不是烟本身，对我来说，烟草其实就和茶叶一样。我想起一句歌词“像我在往日还没抽烟”，很难想象，如今烟、酒竟成了愁绪的代名词，好像一拿起一支烟就是多么不开心一样，为什么要人为的去制造某种情绪的氛围，以此渲染肤浅的近似表演的戏剧色彩。我连续点了十八支烟，它们从此不再占用我的背包空间，不再有负重，连带着打火机也不用了，不听那些大道理，我依然可以过好这一生。</p><p>以上就是我他妈的漫长的一天。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从凌晨一刻开始，我已经整整四个钟头没写一句话，洗手台下面的水管一直漏水，昨天我就发现了，也可能是前天，水就这么稀里里地流，我能想象它把房间充满，湿漉漉的被子死死压在身上，重得像这茫茫夜色的寂静，然而，除了夜什么也没发生。此时，房间另一边传来吱呀吱呀的声音，是突然侧身的室友，
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我为什么活着</title>
    <link href="http://www.luofeng.com/2016/07/15/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B4%BB%E7%9D%80/"/>
    <id>http://www.luofeng.com/2016/07/15/我为什么活着/</id>
    <published>2016-07-14T18:11:30.000Z</published>
    <updated>2017-11-25T09:27:45.942Z</updated>
    
    <content type="html"><![CDATA[<p>想写这篇文已经是几天之前，而真正开始动笔却是在这燥热的凌晨一点半。我想，人之所以还活着的理由，大概是为了反驳他的懒惰和一无是处。在我已完结的短暂生命里，有过爱恨，有过哀乐，有过离别与重逢，有过失望和期望，我以为我经历的已经是我的全部，而接下去的日子似乎变得无足轻重，开始在时间上堕落，就好像左手做了一件明知错误的事，右手却埋在深深的自责之中。我知道我沦落到了某个边缘之上，当我问自己你为什么而活的时候，我很诧异我究竟找不到什么确切的字眼形容。入夜的风同这无边的黑色一样，虽然不知道它确切地从哪里开始，到哪里结束，却一直真实存在着。</p><p>十五年前我刚上学，爷爷是在那年去世的，头七当天晚上，我们聚在未分家前的老屋子里折草纸冥具，等走完仪式，便按着曲折小路回实际的住处，路过一家废宅时，看到有零星的萤火虫熠熠飞过。那是七月份吧，大概只有七月份才会有萤火虫，夏季的晴晚，月光在银色系带中移过头顶。听到大伯谈姐姐的学习情况，说以后要和小叔一样做个文化人，那时姐姐成绩很好，她和小叔相差十五岁，十五年后她或许真的会成为文化人，那我呢？那我呢，我曾无数次从这间废宅走过，但我从来没想过十五年后我会成为什么样子，我只是好奇这间屋子的拥有者去哪里了，为什么破旧的门板上每年都会换新的对联。人总有某种归属感，活着的时候归属一间屋子，一间总是换着门联的废宅；死了，便归属坟墓，立一个碑，也要学活的时候搞个联子，做还活着的假象。</p><p>究竟为了什么而活着呢，或者说为什么活着才好呢，我想首先我得明白我，我想要什么，生活能给我什么，我又能改变什么。这些无非就是万事向前看的废话，因为到此为止你所获得的可能根本微不足道，甚至无所谓有无，在新的时间段里，它大多被遗忘，当你怀揣某种既定目标面向未来，希望能够得到一些有意义的回报，然后遇到一些人，又或者和一些人分开，然而，这些不过作为更远未来的过去又被遗忘，除此之外，便被胡乱记在歌词华丽的谎言里，“往事就像是一道桥，你我会过去的，情怀不会倒退”。</p><p>曾经我很信服村上在《挪》里写的“死不是生的对立面而作为生的一部分永存”，也因此会无缘故萌生一种自杀的冲动，我把心隔离在水银温度计的一端，总希冀有那么一个人能让我热到足以冲破禁锢，从那时起便有了恋人。当你喜欢什么人的时候，会觉得时光很短，剩下的日子都用来思念，而一旦想到死亡，便硬生生堕入虚无，怕从未留下什么证明你们爱过。令我没想到的是，恋人，并非一座桥而是一艘船，你始终在温度计里，只不过有了依靠，在飘摇里安定，在热血中平凡。或者，你会想，哪一天，你们结婚，有了小孩，抚育他们成人，尔后，苍老，从年华的景深中淡去。这时候，再记起王先生所作“况修短随化，终期于尽”的句子，“未尝不临文嗟悼，不能喻之于怀”。</p><p>死生向来同命运相关，而我又不是信命的人，很小时起就认为人应该是运命的，想来这亦是人类作为地球霸主屹立不倒的缘由之一，正是不同的命运和命运的交集缔造了不同的文明和文明的发展，事实上大部分人都是被命运奴役的，如同1984中所说“个人记忆被集体记忆掩盖”。一个人在自己记忆被忘却时能够怀疑自我的真实性，这是独立思考的基础，也是我活着另一个理由。我身边有太多这样的人——他老实、努力、很少犯错、生活规律——我只需见上一面就能看清他的未来。他所信任的不应该是真理部创造的，而是通过自我思考得到的，人存在的意义是为了给世界创出价值，而非其它生命，随历史的轮转消逝殆尽，我悟到了，那他们呢？</p><p>这些年来，我一直如此苟活着，身边不停有人死去，每次母亲告诉我又有谁离世时，我没有一丝怜悯。这世上原本就有死生，那些曾经陪在身边的人，哪一天突然离开，这便是死，哪一天偶然重遇，这又是生，至于他是不是他，是死是生，已不重要，佛说，刹那即是永恒，一息便有轮回。</p><p>时间是永恒的参照，思维才是永恒，相对论中讲当速度等于光速，时间就会静止，超过光速，就能知晓未来，那过去呢，它被永远埋葬。人是思维的载体，它拥有思考这个方法，当他存在思维时，思考便作为一个永真式一直循环下去，每个人能都继承自这个类，重写它的思考方法，而以上便是我思考方法体的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想写这篇文已经是几天之前，而真正开始动笔却是在这燥热的凌晨一点半。我想，人之所以还活着的理由，大概是为了反驳他的懒惰和一无是处。在我已完结的短暂生命里，有过爱恨，有过哀乐，有过离别与重逢，有过失望和期望，我以为我经历的已经是我的全部，而接下去的日子似乎变得无足轻重，开始在时
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.luofeng.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.luofeng.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
