[{"title":"春秋","date":"2017-01-14T20:56:15.000Z","path":"2017/01/15/春秋/","text":"长这么大，好像还是第一次进医院，不是什么大事，也有些心慌慌的，所谓初生牛犊不怕虎，大概如此。做过不少梦，幻想过许多美好的事，没来得及做或者做得更好。有一段时间，大脑像被抽成空白，然后疯狂地去补别人的故事，每逢过节，伪装成失落的恋人，在漆白的桦树林间偶遇谁，沿断桥的河岸线错过谁，从人群的雨伞下回望谁，让公车的玻璃窗画了谁，好像自己是每个故事的主角。我有点分裂，还是活着像个演员。原来就经常头痛，现在又多了胃痛，不知道肾好不好，神经衰弱，然后心理也有点抑郁，去办银行卡人家说我话都说不好不给我办，车也不会骑每次都变成别人的累赘。苟延残喘是一回事，要是被说没上进心是另一回事，被人收做妹妹也是另一回事。记得有一次是哪个假期，去看哪个同学的家人，同学是女同学，不确切是哪个，那个时候以为一定会记一辈子，没想到现在就忘了，那里和港口很近，过了一条街就是长堤，落日的余辉随波起伏，退潮的堤岸边被种上时令蔬菜，有游玩的情侣在互相拍照，身后是城市的音乐声，远方依旧是金鳞的水面，一望无际，货船只是呜呜向前。今天没事听起了半岛铁盒，它是一本书吗，如果是那去哪里买呢。某伦已经身为人父了，感谢在我的生命里有过他的演唱会。很庆幸当我睁开眼的时候，依然能看到你，白天，外面阳光灿烂，把自己关在开灯的房间里，季围巾戴帽子，不发出声音，就是来回走。我想，如果明天，我不再存在，请你记得，今天我喜欢过你。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.com/tags/随笔/"}]},{"title":"再见理想","date":"2016-10-24T08:53:07.000Z","path":"2016/10/24/再见理想/","text":"再见理想从九阳小店回去的时候，天就突然下起雨了，雨滴在门牌延伸的牛皮毡布上，噼啪噼啪的，像腊月深冬里的雪子，小店的砂锅气灶就摆在毡布下，沿街吹过的风，让幽紫色的火焰一闪一闪，沸腾溢出的汤水，在锈掉的金属灶具上滋一下就没了，老板忙着招呼客人，玻璃门内流出一股暖黄色的光，我到隔壁便利店买十块钱一包的烟，靠着墙根狭窄的干处往回走，路上浓密的墨点越来越重，小巷尽头，勾勒出农家枣树的稀疏掠影。 辗转数月，去过几个城市，见过不同地方的人。假如把自己置身世外，看广场上被俗世溜达的宠客，看晴晚远飞的流浪航班的警灯，看一群不知所云的方言嬉笑， 一个月了，知道所谓假如是没有假如的，我成了在城市街道上往来的实体，被运输工具置于生活与工作的两极。七点整，沿深巷往路口走，听到各式各样的闹铃，一边讥讽这些机械声线存在的意义，一边自豪着成为生物钟的异样光辉。晚上六点下班，城市的夜华灯初上，有些人的生活才刚刚开始，我钟情王菲唱的末班车，钟情夜色深处的暧昧红色。 雨下了好久，城市的桂树花开了又谢，撑一把黑色雨伞，去勤业路的便民超市买米，一辆私家车的前窗落满桂花花瓣，颜色很新，想来昨夜风雨严峻，自己却一无所知。最是人间留不住，下一句是什么。 时间是窗前一幢幢砖红色的屋顶，我数着数着的时候就真的失掉了，一开始还是秒、分钟、小时，后来就变成天、星期、月了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.com/tags/随笔/"}]},{"title":"Design设计","date":"2016-09-09T08:15:53.000Z","path":"2016/09/09/Design设计/","text":"Design设计在开发之前导入design包com.android.support:design，design包是跟随android5.0一起提出的，配合Material Design有非常好看的效果 TabLayout选项卡的标签布局，配合ViewPager使用，首先在XML布局文件中引入 1234567&lt;android.support.design.widget.TabLayout android:id=“@+id/tab” android:layout_width=“match_parent” android:layout_height=“wrap_content” … &gt;&lt;/android.support.design.widget.TabLayout&gt; TabLayout专有属性要在独立命名空间下，在布局文件的根布局下引入 xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; `&lt;/pre&gt; 这里署名为`app`，则在下面属性也要用`app`，下面是一些属性，标签文字的大小无法直接用`size`属性指定，只能用`tabTextAppearance`属性直接指定style样式 &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;5&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app:tabBackground=&quot;@color/colorPrimary&quot; //标签栏的背景&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabTextColor=&quot;@android:color/white&quot; //未选中标签文字的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabIndicatorColor=&quot;@android:color/white&quot; //滑块的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabSelectedTextColor=&quot;@color/colorAccent&quot; //选中标签文字的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabMode=&quot;scrollable&quot; //标签的模式，如果标签比较多时会跟随页面滚动&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; java代码中与ViewPager联动 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;5&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ViewPager pager = (ViewPager) findViewById(R.id.pager);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;TabLayout tab = (TabLayout) findViewById(R.id.tab);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;MyAdapter adapter=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyAdapter(getSupportFragmentManager(),list);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;pager.setAdapter(adapter);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;tab.setupWithViewPager(pager); &lt;span class=&quot;comment&quot;&gt;//在pager内容设置好后，设置与TabLayout的联动&lt;/span&gt;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; TabLayout标签上的文字来自于ViewPager，需要重写adapter的`getPageTitle()`方法 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CharSequence &lt;span class=&quot;title&quot;&gt;getPageTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; position)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list.get(position);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; ## [](#DrawerLayout &quot;DrawerLayout&quot;)DrawerLayout 包括内容和抽屉(`NavigationView`)，可以选择覆盖toolbar或者跟toolbar联动，覆盖只需要把toolbar布局作为DrawerLayout内容的一部分，不覆盖则DrawerLayout应该在toolbar的下方，可以拥有抽屉的一个汉堡动画 ToolbarToolbar用来代替ActionBar可以更自由的摆放 1.backgruound属性用来指定toolbar的背景，theme属性用来指定整个主题，@style/ThemeOverlay.AppCompat.Dark.ActionBar&amp;quot;这个主题前景色是白色 1234567&lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” android:background=“@color/colorPrimary” android:layout_width=“match_parent” android:layout_height=“wrap_content” app:theme=“@style/ThemeOverlay.AppCompat.Dark.ActionBar”&gt;&lt;/android.support.v7.widget.Toolbar&gt; 2.在设置toolbar之前，应该先把程序原来的actionBar去掉，换NoActionBar的主题，例如Theme.AppCompat.Light.NoActionBar 3.在setContentView()方法之后，找到toolbar然后设置，setDisplayHomeAsUpEnabled()方法可以添加一个箭头图标，在有父Activity时能够返回 123Toolbar toolbar= (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar);getSupportActionBar().setDisplayHomeAsUpEnabled(true); NavigationView扮演抽屉导航中的抽屉，必须设置layout_gravity属性，代表向哪个方向滑动，特有属性也是在app命名空间下 1234567891011121314151617181920&lt;android.support.v4.widget.DrawerLayout android:id=“@+id/drawer” android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; &lt;LinearLayout android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; … &lt;/LinearLayout&gt; &lt;android.support.design.widget.NavigationView android:id=“@+id/nav” android:layout_gravity=“start” app:menu=“@menu/navigation” app:headerLayout=“@layout/header” app:itemTextColor=“@color/item_bg_select” app:itemIconTint=“@color/item_bg_select” android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 1.设置抽屉里的菜单 新建menu文件，group标签内的item是一组单选菜单，有选中和未选中之分，item-menu-item承接出来的菜单有子菜单的效果，会有一条横线隔开 12345678910111213141516171819202122232425&lt;?xml version=”1.0” encoding=”utf-8”?&gt;&lt;menu xmlns:android=“http://schemas.android.com/apk/res/android“&gt; &lt;group android:checkableBehavior=“single”&gt; &lt;item android:id=“@+id/single_1” android:icon=“@mipmap/ic_launcher” android:title=“单选1” /&gt; &lt;item android:id=“@+id/single_2” android:icon=“@mipmap/ic_launcher” android:title=“单选2” /&gt; &lt;/group&gt; &lt;item android:title=“子菜单”&gt; &lt;menu&gt; &lt;item android:id=“@+id/nav_item_1” android:icon=“@mipmap/ic_launcher” android:title=“菜单1” /&gt; &lt;item android:id=“@+id/nav_item_2” android:icon=“@mipmap/ic_launcher” android:title=“菜单2” /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 在NavigationView中配置app:menu属性，即上面的menu文件 2.设置抽屉里的header，显示用户的头像和用户名 新建header布局文件，写死header的高度，设置背景色，添加Imageview和Textview承载用户头像和名字 12345678910111213141516&lt;LinearLayout xmlns:android=“http://schemas.android.com/apk/res/android“ android:layout_width=“match_parent” android:layout_height=“200dp” android:gravity=“center” android:background=“@drawable/header_bg” android:orientation=“vertical”&gt; &lt;ImageView android:src=“@mipmap/ic_launcher” android:layout_width=“wrap_content” android:layout_height=“wrap_content” /&gt; &lt;TextView android:layout_marginTop=“16dp” android:layout_width=“wrap_content” android:layout_height=“wrap_content” android:text=“用户名”/&gt;&lt;/LinearLayout&gt; 在NavigationView中配置app:headerLayout属性，即上面的layout文件 3.设置抽屉的监听事件和与toolbar的联动 寻找到drawerlayout后利用ActionBarDrawerToggle对象控制toolbar上的图标与抽屉的联动 12345678910111213141516drawer = (DrawerLayout) findViewById(R.id.drawer);ActionBarDrawerToggle toggle=new ActionBarDrawerToggle(this, drawer,toolbar,0,0);drawer.addDrawerListener(toggle);toggle.syncState(); //同步状态 开或关给NavigationView添加监听事件，并重写监听回调nav.setNavigationItemSelectedListener(this);…public boolean onNavigationItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.nav_item_4: //事件处理 finish(); break; &#125; drawer.closeDrawer(GravityCompat.START); //每次点击后关闭抽屉 return true;&#125; SnackBar这个控件和Toast相似，出现位置是屏幕下方，可以给它添加动作，比如撤销，在CoordinatorLayout中可以配合侧滑删除 1234567Snackbar.make(view,“snackbar”,Snackbar.LENGTH_SHORT).setAction(“撤销”, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; text.setVisibility(View.VISIBLE); text.animate().alpha(1); &#125; &#125;).show(); CoordinatorLayout继承自FrameLayout，在没有设置Behavior之前和帧布局无差，通过给它里面的控件设置Behavior可以达到不同的效果。 自定义Behavior 一系列的行为监听，当发生什么事情，应该做什么事情。给控件设置Behavior的方式有三种。 1.创建自定义Behavior类继承自系统的Behavior，重写onStartNestedScroll()方法和onNestedPreScroll()方法 1234567891011public class MyBehavior extends CoordinatorLayout.Behavior &#123; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return true; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, // TODU: &#125;&#125; 然后通过控件的LayoutParams设置 12CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) text.getLayoutParams();layoutParams.setBehavior(new MyBehavior()); 2.重写Behavior两个参数的构造方法 123public MyBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125; 在xml布局文件里给相应控件设置上layout_behavior属性 `app:layout_behavior=&quot;luofeng.study.com.app1.MyBehavior&quot; 3.第三个方法是在自定义控件时，利用注解框架绑定，参考FloatingActionButton AppBarLayoutAppBarLayout是对toolbar的在CoordinatorLayout上的外层嵌套，例如下滑隐藏，和悬停提示。如果是只要上滑就显示toolbar，把scrollFlags属性设置为enterAlways，如果要到滑动布局的最顶端再显示，则用enterAlwaysCollapsed 1234567891011121314151617&lt;android.support.design.widget.AppBarLayout android:layout_width=“match_parent” android:layout_height=“wrap_content” app:theme=“@style/ThemeOverlay.AppCompat.Dark.ActionBar”&gt; &lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” app:layout_scrollFlags=“scroll|enterAlwaysCollapsed”&gt; android:layout_width=”wrap_content” android:layout_height=”?actionBarSize”&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=“match_parent” android:layout_height=“wrap_content” android:text=“悬停条目”/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 这里需要注意的是，因为CoordinatorLayout是帧布局，在设置AppBarLayout后会遮住下面滚动布局的条目，可以通过修改它的layout_behavior属性避免。RecyclerView必须设置LayoutManager才可以使用 1234567&lt;android.support.v7.widget.RecyclerView android:id=“@+id/rv” android:layout_width=“match_parent” android:layout_height=“match_parent” app:layoutManager=“LinearLayoutManager” app:layout_behavior=“@string/appbar_scrolling_view_behavior”&gt;&lt;/android.support.v7.widget.RecyclerView&gt; CollapsingToolbarLayout可折叠的toolbar，是appbarLayout+toolbar的一种升级版，使用方法是在上面的toolbar上套一层CollapsingToolbarLayout布局，并把scollFlags属性移给它，修改值为exitUntilCollapsed，在下滑隐藏时会保留一个actionbar的位置 123456789101112131415161718&lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=“match_parent” android:layout_height=“wrap_content” app:contentScrim=“@color/colorPrimary” app:layout_scrollFlags=“scroll|exitUntilCollapsed”&gt; &lt;ImageView android:layout_width=“match_parent” android:layout_height=“160dp” app:layout_collapseMode=“parallax” android:src=“@mipmap/ic_launcher”/&gt; &lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” android:layout_width=“wrap_content” android:layout_height=“?actionBarSize”&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 设置的ImageView可以有一个压缩的过程，CollapsingToolbarLayout的app:contentScrim是对压缩后的toolbar的遮蔽处理，通常设置为toolbar原来的颜色，imageview的app:layout_collapseMode属性指定了折叠模式，默认是向上推进，parallax是上下同时压缩。 FloatingActionButton浮动按钮，跟ImageButton最大的不同是，它和SnackBar处在同一层，它会因为SnackBar的show而升高，这也是它的名字的来由。它一般放置在AppBar的右下方 1234567&lt;android.support.design.widget.FloatingActionButton android:id=“@+id/fab” app:layout_anchor=“@id/appbar” app:layout_anchorGravity=“end|bottom” android:layout_width=“wrap_content” android:layout_height=“wrap_content” android:src=“@mipmap/ic_launcher”/&gt; FloatingActionButton的位置可以随意定，可以修改它的默认Behavior但是，重新设置后会覆盖原来的行为，因此，在使用时尽量去继承自具体的FloatingActionButton的Behavior类。 1234567&lt;android.support.design.widget.FloatingActionButton android:id=“@+id/fab” android:layout_gravity=“end|bottom” android:layout_width=“wrap_content” android:layout_height=“wrap_content” app:layout_behavior=“luofeng.study.com.app1.MyBehavior” android:src=“@mipmap/ic_launcher”/&gt; TextInputLayout文本输入布局，对输入文本有所优化，例如text提示，和基本的输入要求判断提示。使用时对EditText做一层包装 123456789&lt;android.support.design.widget.TextInputLayout android:id=“@+id/til” android:layout_width=“match_parent” android:layout_height=“wrap_content”&gt; &lt;EditText android:layout_width=“match_parent” android:layout_height=“wrap_content” android:hint=“用户名”/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 通过对EditText文本输入的监听，调用TextInputLayout相关方法提示 12textInput = (TextInputLayout) findViewById(R.id.til);extInput.getEditText().addTextChangedListener(this); 在输入文本时，会有一个错误提示 12345678public void afterTextChanged(Editable editable) &#123; if (editable.length()&lt;6) &#123; textInput.setError(“用户名不得少于6位”); textInput.setErrorEnabled(true); &#125;else &#123; textInput.setErrorEnabled(false); &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"http://www.luofeng.com/tags/android/"},{"name":"笔记","slug":"笔记","permalink":"http://www.luofeng.com/tags/笔记/"},{"name":"design","slug":"design","permalink":"http://www.luofeng.com/tags/design/"}]},{"title":"android-async-http源码分析","date":"2016-08-24T23:02:15.000Z","path":"2016/08/25/android-async-http源码分析/","text":"android-async-http源码分析今天开始学习android-async-http的源码了 构造方法一共有五种构造方法，前三种都是调用这个有三个参数的，其余三个都是对这三个参数的其中几个或所有做固定赋值 12345678910/* Creates new AsyncHttpClient using given params @param fixNoHttpResponseException 是否通过忽略ssl认证自动修复连接无响应 @param httpPort http端口号 @param httpsPort https端口号*/public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) &#123; this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));&#125; 然而这个构造方法也没有具体实现，内部调用的是this(SchemeRegistry schemeRegistry)，getDefaultSchemeRegistry返回一个SchemeRegistry对象 12345678private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) &#123; … SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme(“http”, PlainSocketFactory.getSocketFactory(), httpPort)); schemeRegistry.register(new Scheme(“https”, sslSocketFactory, httpsPort)); return schemeRegistry;&#125; 其实SchemeRegistry就是对这些协议的封装，利用map存了起来，http、https这些协议名称为key，具体的Scheme类就不看了 12345public final Scheme register(final Scheme sch) &#123; Args.notNull(sch, “Scheme”); final Scheme old = registeredSchemes.put(sch.getName(), sch); return old;&#125; 最后回到构造方法来，内部到底怎么实现的，好长，就是初始化了一些网络请求参数，然后线程池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public AsyncHttpClient(SchemeRegistry schemeRegistry) &#123; BasicHttpParams httpParams = new BasicHttpParams(); //默认的http请求参数 //设置httpParams参数的内容 ConnManagerParams.setTimeout(httpParams, connectTimeout); ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections)); ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS); HttpConnectionParams.setSoTimeout(httpParams, responseTimeout); HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout); HttpConnectionParams.setTcpNoDelay(httpParams, true); HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE); HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1); //协议版本 //线程安全的连接管理者 ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams); Utils.asserts(cm != null, “Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null”); threadPool = getDefaultThreadPool(); //得到一个线程池对象 //一个请求的map 封装了上下文和该上下文对应的请求的Handler的集合 该Handler用来管理一个请求 比如取消请求 requestMap = Collections.synchronizedMap(new WeakHashMap&lt;Context, List&lt;RequestHandle&gt;&gt;()); clientHeaderMap = new HashMap&lt;String, String&gt;(); //客户端请求头的一个map httpContext = new SyncBasicHttpContext(new BasicHttpContext()); //一个HttpClient对象 httpClient = new DefaultHttpClient(cm, httpParams); //添加一个请求拦截器，给请求Header添加gzip编码，替换重写的某些请求头参数 httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123; @Override public void process(HttpRequest request, HttpContext context) &#123; if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; //添加gzip编码 request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP); &#125; for (String header : clientHeaderMap.keySet()) &#123; //遍历所有的Header的键 if (request.containsHeader(header)) &#123; //如果请求Header里面包含这个键，就是说有自定义的Header参数 Header overwritten = request.getFirstHeader(header); //获得这个Header参数的值 log.d(LOG_TAG, String.format(“Headers were overwritten! (%s | %s) overwrites (%s | %s)”, header, clientHeaderMap.get(header), overwritten.getName(), overwritten.getValue()) ); //remove the overwritten header request.removeHeader(overwritten); //移除这个值 &#125; request.addHeader(header, clientHeaderMap.get(header)); //在相应键位上添加clientHeaderMap里的header参数 &#125; &#125; &#125;); //对响应做拦截，对gzip做解码 httpClient.addResponseInterceptor(new HttpResponseInterceptor() &#123; @Override public void process(HttpResponse response, HttpContext context) &#123; final HttpEntity entity = response.getEntity(); //获得内容 if (entity == null) &#123; return; &#125; final Header encoding = entity.getContentEncoding(); //获得编码方式 if (encoding != null) &#123; for (HeaderElement element : encoding.getElements()) &#123; if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) &#123; //为gzip编码 response.setEntity(new InflatingEntity(entity)); //解码之后重新设置内容 break; &#125; &#125; &#125; &#125; &#125;); //做认证的，暂时没看，和上面那个唯一不同的是，它排在拦截list的第0位，应该首先处理这个？？ httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123; … &#125;, 0); //设置重新请求 httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));&#125; get、post调用在new完对象之后，我们都是直接拿着去调get()、post()方法，下面就去看看，先看get()，一共有6个重载 123456789101112131415161718192021222324252627//1.只有url和响应接口，调用的重载4public RequestHandle get(String url, ResponseHandlerInterface responseHandler) &#123; return get(null, url, null, responseHandler);&#125;//2.加上一个params请求参数，调用重载4，经常用这个public RequestHandle get(String url, RequestParams params, ResponseHandlerInterface responseHandler) &#123; return get(null, url, params, responseHandler);&#125;//3.没有params，但是多一个context，调用重载4public RequestHandle get(Context context, String url, ResponseHandlerInterface responseHandler) &#123; return get(context, url, null, responseHandler);&#125;//4.调用sendRequest()方法public RequestHandle get(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);&#125;//5.设置传入的header再调用sendRequest()public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) &#123; HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)); if (headers != null) request.setHeaders(headers); return sendRequest(httpClient, httpContext, request, null, responseHandler, context);&#125;//6.use this to send string/json/xml，然后再调用sendRequest()方法public RequestHandle get(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);&#125; 最终调用都是sendRequest()，而且方法是有返回值的，类型是RequestHandler，这个类好像在哪里见过，没错就是这 requestMap = Collections.synchronizedMap(new WeakHashMap&amp;lt;Context, List&amp;lt;RequestHandle&amp;gt;&amp;gt;());在AsyncHttpClient的构造方法里，我们创建了这么一个map，里面存着以Context为键泛型为RequestHandler的list集合。再看一眼post方法 123public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(getURI(url)), entity), contentType, responseHandler, context);&#125; 嘿嘿，果然和get方法一样，最后都是调用sendRequest()，返回值也都是RequestHandler对象。先看sendRequest() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* put一个新请求到线程池的执行队列里 @param client 就是构造方法里初始化的一个DefaultHttpClient @param contentType MIME body type，may be null，某些get、put方法里有这个参数 @param context Android上下文，持有这个request请求，为了cancel() @param httpContext HttpContext in which the request will be executed @param responseHandler 处理响应的接口 @param uriRequest 必须是HttpUriRequest的实例，封装了url和请求参数等等 /protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) &#123; //uriRequest必须非空 if (uriRequest == null) &#123; throw new IllegalArgumentException(“HttpUriRequest must not be null”); &#125; //responseHandler必须非空 if (responseHandler == null) &#123; throw new IllegalArgumentException(“ResponseHandler must not be null”); &#125; //异步请求里面不能使用同步响应处理 if (responseHandler.getUseSynchronousMode() &amp;&amp; !responseHandler.getUsePoolThread()) &#123; throw new IllegalArgumentException(“Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.”); &#125; //设置自定义的contentType if (contentType != null) &#123; if (uriRequest instanceof HttpEntityEnclosingRequestBase &amp;&amp; ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != null &amp;&amp; uriRequest.containsHeader(HEADER_CONTENT_TYPE)) &#123; log.w(LOG_TAG, “Passed contentType will be ignored because HttpEntity sets content type”); &#125; else &#123; uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType); &#125; &#125; //确保以上这些都检查完并设置好之后，把uriRequest的一些参数复制给responseHandler一份 responseHandler.setRequestHeaders(uriRequest.getAllHeaders()); responseHandler.setRequestURI(uriRequest.getURI()); //创建一个AsyncHttpRequest对象，把这个对象添加到线程池的执行队列中，创建一个RequestHandler对象 AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context); threadPool.submit(request); RequestHandle requestHandle = new RequestHandle(request); //context不为空，把上面的requestHandler放到Map中去 if (context != null) &#123; List&lt;RequestHandle&gt; requestList; // Add request to request map synchronized (requestMap) &#123; requestList = requestMap.get(context); if (requestList == null) &#123; requestList = Collections.synchronizedList(new LinkedList&lt;RequestHandle&gt;()); requestMap.put(context, requestList); &#125; &#125; requestList.add(requestHandle); //遍历集合，如果发现有requestHandler对应的request已经消费完，则移除当前requestHandler Iterator&lt;RequestHandle&gt; iterator = requestList.iterator(); while (iterator.hasNext()) &#123; if (iterator.next().shouldBeGarbageCollected()) &#123; iterator.remove(); &#125; &#125; &#125; return requestHandle; //返回requestHandle&#125; 这里知道我们所有的请求最后都被封装到了AsyncHttpRequest，然后把它交给了线程池，然后再处理了下RequestHandler，并返回，下面看看这个RequestHandler 1234567891011121314151617181920212223242526272829303132333435public class RequestHandle &#123; private final WeakReference&lt;AsyncHttpRequest&gt; request; public RequestHandle(AsyncHttpRequest request) &#123; this.request = new WeakReference&lt;AsyncHttpRequest&gt;(request); &#125; //用于取消当前request，就算返回true也并不一定是真的取消成功了，只是尝试去取消 public boolean cancel(final boolean mayInterruptIfRunning) &#123; final AsyncHttpRequest _request = request.get(); if (_request != null) &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; _request.cancel(mayInterruptIfRunning); &#125; &#125;).start(); return true; &#125; else &#123; return _request.cancel(mayInterruptIfRunning); &#125; &#125; return false; &#125; //如果当前request被取消了或者完成了，则把当前request对象=null，不是引用，而是里面包裹的AsyncHttpRequest public boolean shouldBeGarbageCollected() &#123; boolean should = isCancelled() || isFinished(); if (should) request.clear(); return should; &#125; …&#125; 它持有一个AsyncHttpRequest对象，这个是在构造方法里面传入的，并且通过弱引用包裹，与上面的sendRequest()方法结合起来就是，在我们调用get()、post()方法发送请求时，它会把我们的一系列请求参数封装，作为一个Request对象扔给了线程池的待执行队列，然后创建一个持有当前Request对象的RequestHandler，并返回给调用者。请求的步骤大概就是这样。 开始异步请求首先，AsyncHttpRequest实现了Runnable接口，现在先看看构造方法 123456public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) &#123; this.client = Utils.notNull(client, “client”); this.context = Utils.notNull(context, “context”); this.request = Utils.notNull(request, “request”); this.responseHandler = Utils.notNull(responseHandler, “responseHandler”);&#125; 就是判断了一下参数是否为空然后赋值，下面就去看它的run方法 12345678910111213141516171819202122232425262728293031323334public void run() &#123; //判断是否取消了，取消则直接返回 if (isCancelled()) &#123; return; &#125; // 判断该Request是否已经准备执行，避免多次执行请求 if (!isRequestPreProcessed) &#123; isRequestPreProcessed = true; onPreProcessRequest(this); &#125; //给调用者发送一个准备开始的消息 responseHandler.sendStartMessage(); try &#123; //开始请求并尝试重新请求 makeRequestWithRetries(); &#125; catch (IOException e) &#123; if (!isCancelled()) &#123; //没有被取消就发送错误消息 responseHandler.sendFailureMessage(0, null, null, e); &#125; else &#123; AsyncHttpClient.log.e(“AsyncHttpRequest”, “makeRequestWithRetries returned error”, e); &#125; &#125; //发送完成消息 responseHandler.sendFinishMessage(); … //设置完成状态 isFinished = true;&#125; 开始请求前给调用者发送了一个开始的消息，然后开始请求，如果请求出错，发送了一个错误的消息，完成后也发送了一个完成的消息，这是整个流程，下面来看看，它是怎么请求的 123456789101112private void makeRequestWithRetries() throws IOException &#123; boolean retry = true; //在AsyncHttpClient的构造方法里我们设置了这么一个东东 HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler(); try &#123; while (retry) &#123; try &#123; makeRequest(); //终于要发送请求了吗 return; &#125; …各种捕获异常，抛异常&#125; 好像还是没有开始请求，接着往里面看 123456789101112131415private void makeRequest() throws IOException &#123; … // 做了下判断，更新Header if (responseHandler instanceof RangeFileAsyncHttpResponseHandler) &#123; ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request); &#125; // 真正的请求在这里 HttpResponse response = client.execute(request, context); … // 发送了一个处理的消息 responseHandler.sendResponseMessage(response); …&#125; 真正的请求开始了，虽然还没见着方法体，可以看到这里根据传入的responseHandler的不同，要做一个响应Header的处理，然后开始请求，然后把返回的response交给responseHandler做响应处理，怎么处理等会儿再看，把request看完先 123456public CloseableHttpResponse execute( final HttpUriRequest request, final HttpContext context) throws IOException, ClientProtocolException &#123; Args.notNull(request, “HTTP request”); return doExecute(determineTarget(request), request, context);&#125; 这个execute是CloseableHttpClient的方法，我们传入的client是它的子类的一个实例，它又调用了doExecute()方法，继续看 12protected abstract CloseableHttpResponse doExecute(HttpHost target, HttpRequest request, HttpContext context) throws IOException, ClientProtocolException; 果然，这是一个抽象类，到底怎么doExecute交给具体的子类实现，下面去找它的实现，在AbstractHttpClient里面找到了这个方法 123456try &#123; out = CloseableHttpResponseProxy.newProxy( director.execute(target, request, execContext)); &#125; catch … return out; 不知道我费劲心思想找这个发送请求的方法干嘛，它又转移了，偷偷瞄了一眼这个execute方法，好长，吓得我赶紧退了回来，具体的怎么请求其实不需要太了解，反正也看不懂，就是一系列封装，最后返回这个out，也就是请求网络完成后的响应， 响应处理现在就来看处理响应的ResponseHandler了 中间代码不贴了ResponseHandler其实是一个接口，封装了响应之后各个阶段的方法，而且框架已经帮我们写了很多实现类，比如常用的AsyncHttpResponseHandler、DataAsyncHttpResponseHandler、TextHttpResponseHandler、JsonHttpResponseHandler、FileAsyncHttpResponseHandler，所以用不着我们自己去实现，针对每种不同的请求方式，这些类会自动做相关的处理，比如请求获得一个文件，会在处理response的时候，直接返回一个file对象，下面来看看AsyncHttpResponseHandler，它是其它几个常用实现类的父类 123456789101112131415161718192021222324252627282930313233// 1.不带参数，一般我们get、post时候就是用这个，匿名对象public AsyncHttpResponseHandler() &#123; this(null);&#125;// 2.第一个构造方法其实就是调用的这个，然后调用第4个构造方法public AsyncHttpResponseHandler(Looper looper) &#123; // 默认使用主线程的Looper this(looper == null ? Looper.myLooper() : looper, false);&#125;// 3.可以手动指定使用线程池所在线程？不一定对，应该是当前Request所在的线程，即同步响应public AsyncHttpResponseHandler(boolean usePoolThread) &#123; this(usePoolThread ? null : Looper.myLooper(), usePoolThread);&#125;// 4.其它构造方法都是调用这个，而这个构造方法是private的// 如果同步响应，loop必须为空，异步响应，loop必须是Looper.myLooper()，而且usePoolThread必定为falseprivate AsyncHttpResponseHandler(Looper looper, boolean usePoolThread) &#123; if (!usePoolThread) &#123; // 异步响应时，初始化了handler对象 Utils.asserts(looper != null, “use looper thread, must call Looper.prepare() first!”); this.looper = looper; this.handler = new ResponderHandler(this, looper); &#125; else &#123; // 如果同步响应，全部置空 Utils.asserts(looper == null, “use pool thread, looper should be null!”); this.looper = null; this.handler = null; &#125; this.usePoolThread = usePoolThread;&#125; 在上面初始化Handler的时候，发现是new了一个ResponderHandler对象，下面去看看它 12345678910111213141516/* Avoid leaks by using a non-anonymous handler class. */private static class ResponderHandler extends Handler &#123; private final AsyncHttpResponseHandler mResponder; ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) &#123; super(looper); this.mResponder = mResponder; &#125; @Override public void handleMessage(Message msg) &#123; mResponder.handleMessage(msg); &#125;&#125; 先看它的注释，通过使用一个非匿名的Handler类来避免泄漏，唉，看别人写的代码就是享受呀，静态内部类，学到了。再看它的实现，把handleMessage方法交给外面的AsyncHttpResponseHandler去处理，下面看看怎么处理的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Methods which emulate android’s Handler and Message methodsprotected void handleMessage(Message message) &#123; Object[] response; try &#123; // 根据收到的消息，调用相关的回调 switch (message.what) &#123; case SUCCESS_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 3) &#123; onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “SUCCESS_MESSAGE didn’t got enough params”); &#125; break; case FAILURE_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 4) &#123; onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “FAILURE_MESSAGE didn’t got enough params”); &#125; break; case START_MESSAGE: onStart(); break; case FINISH_MESSAGE: onFinish(); break; case PROGRESS_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 2) &#123; try &#123; onProgress((Long) response[0], (Long) response[1]); &#125; catch (Throwable t) &#123; AsyncHttpClient.log.e(LOG_TAG, “custom onProgress contains an error”, t); &#125; &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “PROGRESS_MESSAGE didn’t got enough params”); &#125; break; case RETRY_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length == 1) &#123; onRetry((Integer) response[0]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “RETRY_MESSAGE didn’t get enough params”); &#125; break; case CANCEL_MESSAGE: onCancel(); break; &#125; &#125; catch (Throwable error) &#123; onUserException(error); &#125;&#125; 第一句的注释意思是，我就模仿Android的Handler来处理消息，根据发送消息的what判断，去调用相关的回调，从start到finish()全部都有，这些消息在什么时候发的呢，在开始的sendRequest的一系列过程中都有所体现，success和failure的消息稍微有点隐晦，是在sendResponseMessage方法中处理的 123456789101112131415public void sendResponseMessage(HttpResponse response) throws IOException &#123; // 如果请求被cancel掉了就不做处理 if (!Thread.currentThread().isInterrupted()) &#123; StatusLine status = response.getStatusLine(); byte[] responseBody; responseBody = getResponseData(response.getEntity()); if (!Thread.currentThread().isInterrupted()) &#123; if (status.getStatusCode() &gt;= 300) &#123; sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase())); &#125; else &#123; sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody); &#125; &#125; &#125;&#125; responseBody从getResponseData()方法中得到，根据响应码的值判断是否成功，发送相应的消息出去，至此为止好像还有一个回调没有发消息，onProgress()，下面来看看 12345678910111213141516171819202122232425262728293031323334byte[] getResponseData(HttpEntity entity) throws IOException &#123; byte[] responseBody = null; if (entity != null) &#123; InputStream instream = entity.getContent(); if (instream != null) &#123; long contentLength = entity.getContentLength(); //获得响应内容的长度 if (contentLength &gt; Integer.MAX_VALUE) &#123; throw new IllegalArgumentException(“HTTP entity too large to be buffered in memory”); &#125; int buffersize = (contentLength &lt;= 0) ? BUFFER_SIZE : (int) contentLength; try &#123; ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize); try &#123; byte[] tmp = new byte[BUFFER_SIZE]; long count = 0; int l; while ((l = instream.read(tmp)) != -1 &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; count += l; buffer.append(tmp, 0, l); sendProgressMessage(count, (contentLength &lt;= 0 ? 1 : contentLength)); &#125; &#125; finally &#123; AsyncHttpClient.silentCloseInputStream(instream); AsyncHttpClient.endEntityViaReflection(entity); &#125; responseBody = buffer.toByteArray(); &#125; catch (OutOfMemoryError e) &#123; System.gc(); throw new IOException(“File too large to fit into available memory”); &#125; &#125; &#125; return responseBody;&#125; sendProgressMessage()在while循环里调用了，循环条件中加了一个是否cancel，如果被取消就没必要再发消息了，finally里面关流，并且把响应内容toByteArray()返回，那么异步响应到此为止全部结束，下面看看同步响应 123456789101112131415161718public void setUseSynchronousMode(boolean sync) &#123; // A looper must be prepared before setting asynchronous mode. if (!sync &amp;&amp; looper == null) &#123; sync = true; AsyncHttpClient.log.w(LOG_TAG, “Current thread has not called Looper.prepare(). Forcing synchronous mode.”); &#125; // If using asynchronous mode. if (!sync &amp;&amp; handler == null) &#123; // Create a handler on current thread to submit tasks handler = new ResponderHandler(this, looper); &#125; else if (sync &amp;&amp; handler != null) &#123; // TODO: Consider adding a flag to remove all queued messages. handler = null; &#125; useSynchronousMode = sync;&#125; sync的值是设置进来的，假设为false，那么就是说我希望是异步响应，然而你的looper为空，所以不可能异步，就强制设置回true。其实想想，looper什么情况下可能为null，那就是在构造方法里传入usePoolThread为true的时候，也就是说刚好也设为同步。如果传入的是true，那就没话说，最后也把mod设置为同步。那么同步mod下怎么处理 12345678protected void sendMessage(Message msg) &#123; if (getUseSynchronousMode() || handler == null) &#123; handleMessage(msg); &#125; else if (!Thread.currentThread().isInterrupted()) &#123; // do not send messages if request has been cancelled Utils.asserts(handler != null, “handler should not be null!”); handler.sendMessage(msg); &#125;&#125; 嘿嘿，只能说设计得太巧妙了，如果是同步模式下，直接处理消息，异步模式才会用handler去发消息，该回调还是回调，但是同步模式下，不能直接更新ui，切记 总结一下AsyncHttpClient核心类AsyncHttpRequest+RequestHandler请求和请求管理ResponseHandler+子类实现+setMod可以同步/异步响应技术要点： 线程池，AsyncHttpRequest实现Runnable接口，添加到线程池执行队列中 AsyncResponseHandler的异步响应，运用了android中的Handler ResponseHandler是一个接口，针对接口编程，扩展性更强","tags":[{"name":"android","slug":"android","permalink":"http://www.luofeng.com/tags/android/"},{"name":"笔记","slug":"笔记","permalink":"http://www.luofeng.com/tags/笔记/"},{"name":"源码","slug":"源码","permalink":"http://www.luofeng.com/tags/源码/"}]},{"title":"瞎子","date":"2016-08-12T22:21:01.000Z","path":"2016/08/13/瞎子/","text":"下午四点二十八分的时候，我接了一个电话，在此之前，我漠视了许多通同一区号的号码，我不知道我接它的理由，只听到聚氯乙烯包裹下的性感女声：“先生，马上要七夕了，你要带着黑眼圈见女朋友吗？”听这口吻，我立马知道对方是为推销护眼类药物而来，像是突然没了什么顾虑般，点开了通话扬声器，一边带着戏谑的语气道。“首先你得有一个女朋友”我的声音很快从四周传递回来，这样的语气，在流火的七月里无疑是一阵清凉。“那你想要带着黑眼圈找女朋友吗？”听筒那边很快传来回复。这女人想卖产品想疯了，白费我一番戏谑的心思。我微微皱眉“我对你要推销的产品一点兴趣也没有”过了几秒又悠然道，“推销产品时你应该先说出一些令人困扰的现状，让你的听众能够在这些困扰中找到认同感，然后告诉他们可能改善的方法，最后引出你要卖的东西。”“你会买吗？”好像怕我没理解，那头又补充道，“如果按你那样说，你会买吗？”“不会”，我说的很快，我很想在她解释之前说完，我生怕她觉得我是那种需要听解释才能懂的人。“你刚才说了什么？”“我说不会，我是那种怎么看电视怎么熬夜眼睛都不会坏的人。”不得不说我确实有双好眼睛，讲这句话的时候我甚至有种自豪感。“你说话真有趣，你也是做微商么”“不是”，然后有点炫耀地说道，“我是个程序员”“嗯？程序员？经常看电脑吧？是不是经常眼睛觉得疲劳？”开始那种性感的声音此时已经蜕变得冷静。“对，偶尔会酸酸的。。。”还没说完，那边响起丝丝笑声，而后又平静下来。“是不是脑袋也会嗡嗡响，太阳穴也会疼，你应该时不时站起来活动下，看看远处，洗把脸。”她顿了顿，好像在水里憋了好久的气。“我最近看到一款对眼睛很好的产品”，她是笑着说这句话的，笑得很大声。我必须得承认这个女子的聪明，有时候我也像她一样。然而此刻我没有说话，一直沉静着。她似乎察觉到自己的失态，于是赶忙停住笑声，这种戛然而止，无异于从一匹纯种白猫身上硬生生长出一撮黑毛。只见那只猫的嘴又动了。“你做程序员一个月多少钱？”我没有仔细去辩证她的问题是否转变得过于突兀，只是支吾道，“嗯…六千、或者七千、大概有八千吧。”我忘了我只是想做一个程序员，到目前为止，并不是。听到这个，那张脸好像又变了，无线电波中都带着嘲讽的意味，“我们做微商一个月随随便便上万，听你说话对销售还颇有天赋，不如加入我们吧。”“其实我并没有什么销售天赋，我就是站在对方的角度想问题，对了，你们除了卖护眼类的还有什么其它的么？”“那你需要什么呢”，她立马回答，这就是一个商人的惯性，就像“can i help you”类的蠢话。“永远保留客户选择的权利，永远不要让自己扎进死胡同。我随便说一个你们没有的东西，你就接不了话了。”我很神气地回她，好像出了口程序员工资没她高的恶气。她好像并未因此气馁，她的声音甜得近乎暧昧，“像你这样的人才不做微商真是可惜了。”“我不喜欢微商，我讨厌销售。”我喊起来。挂掉电话，回音还在继续，我从没仔细听过自己的音色，此时，觉得跟夜深人静处的狗吠很像。我是个瞎子，干嘛要买护眼产品，而一个瞎子，难道能做销售吗？一个月前，我开始有变成瞎子的动向，这些，都是在很久之后才觉悟到。一开始的时候，只是晚一点去食堂吃饭，后来演变成躲在角落吃饭，再后来是打饭都塞着耳机，前几日已经要戴着帽子才敢去食堂了。这一过程中我慢慢出现幻觉，也会幻听，夜了也不开灯，喜欢躺着，看大量的故事，却懒得动笔。至此为止，我都没变成一个瞎子。然而昨天的那场面试，却把我死死打入瞎子的地狱。这个月来，我陆陆续续参加过许多场面试，大多数无疾而终。我以为，这次也一样。从电梯上走出来的时候，旁边是群谈论高级历史的年轻烟民，“秦始皇上六代分别叫什么名字”，这个声音来自一名穿棕色仿牛皮人字拖、脱水的半截海蓝牛仔裤的亢奋男子，他脸型偏瘦，脸色像极了吸水后的焦黄烟蒂，原本应该呈现的自然忧虑的眉目，此刻毅然舒展开，与他嘴角的一丝弧度交相呼应。我很快走过他们，我自诩博览群书却回答不出他的问题，只知道答案中有个嬴字。面试公司就在转弯的第一处入口，一扇玻璃门半掩着，正对门是一堵冰淇淋色的隔墙，上面彩绘着xx科技有限公司几个大字，门的左边摆一张纵向的咖啡木案，除了几封松弛的蓝底文件夹，其上再无他物。那堵墙的右边，也就是这半掩着的门的后面，应该就是真正的办公地点，只是此刻隔着不全透明的玻璃望去，却有几分像犹抱琵琶的歌女。推门进去之后，便看到琵琶遮住的全貌，木案的前方，是张小巧的圆形桌子，颜色呈深黑，之间夹杂一些淡雅的不规则浮纹，边缘被精心打磨过，人影经掠处，显现出一种复古的贵金属光晕。桌子向后三米，就到了真的办公区，地面沿那堵横墙分开，往下，要低一个门槛的高度，那里是踏踏实实的水泥地，与这边的青花瓷砖相比，破落的像是三流城镇里的年修国道。在那之上，摆放着两排背向的电脑，在我目光流转下迅速向两旁排列开去。“我是过来面试的”，我边说边朝前台走。前台是只很温顺的妹子，她指了指我身后的圆桌，“先坐会儿吧。”我回头看了一眼，就是刚刚看到的那张桌子，那儿正坐着三个人，三名女性。她们低着头在写些什么。我没说话，只是安静地向外走去。左边走廊的尽头传来断续的女子对话，时而嬉笑，时而哀叹，我能猜到她们是时尚的妙龄女郎，还有一个摄影师，她们丝毫不为自己的美丽感到担忧，游离在光与影的稍纵即逝里。我来回踱步，或是低头沉思，或是徒对天花，偶尔停下在墙壁上画上几笔抽象的名迹，一边还用余光瞄两眼门后的三人小圆桌。约莫过了六七分钟，出来一个接电话的男子，声音很浑厚，方言也听不懂，语气倒是比之前的电梯烟民俏皮些，我未及仔细看清他的样子，便顺着他拉开的门缝钻进去了。桌子边上只留下一个人，头发染成橙红色，落在肩上的发梢翘起微卷的尾巴，我移步桌子，坐在离她150度角的饮水机的斜前方。前台妹子见我过来就让填了信息表，顺带帮我们两个人到了一杯水，橙红色女郎显得有些讶异，抬起头的时候连忙说了声谢谢。很快，桌子边只剩我了，那女子被带进去的时候喝了口水，我听说人紧张的时候喉咙就会变得很干，所以她喝之后没多久我也喝了，不过是自己带的水，我以为，只要不喝别人的水，就不用说谢谢。开始有很多人走动，很多人来我身后的饮水机装水，出去接电话的男子也回来了，甚至那群电梯烟民也进来了，跟着进来的还有一名无害的龅牙妹。我惶恐于那群烟民同属这家公司，我深怕成为这提出“秦始皇上六代叫什么名字”的高级学问的文化人的同僚。然而令人庆幸的是，那个无害的龅牙妹依然无所适从的笑着，她作为一个同我一样的求职者，好像对此习以为常。她对着身份证填个人信息，从百度文库偌大的自然段中寻找自己的优缺点，我不禁笑出来，好像听到这个世上最好笑的笑话。在我进入面试之前，有个手拿相机的男子冲进来，一小会又急匆匆的跑出去，这样的画面，在我跟hr聊的时候一直闪现着，究竟是什么使得他这样紧迫呢。有那么一瞬间，我看到龅牙妹和另一名女性面对着坐在沙发上，她们一样无害，一样笑容可掬。也是在那一瞬间，又变得模糊，好像她们并没有出现过。聊以慰藉的交谈总让人寂寞，我就一直接受着来自寂寞的字眼，无论多么喋喋不休。我的心，早已随着18层高楼下小的可怜的汽车引擎逃离。出去的时候，那些看电影的人依然在看电影，玩游戏的依然在玩游戏，聊天的依然在聊天，我同前台的妹子挥手告别，推开门的瞬间，室内节能灯在茶色地板上投下巨大的黑影。我不知道所谓瞎子的定义，我把自己关在柜子里，四周一片黑暗。微弱的回音从黑暗中荡开去，然而没有人听到，那是手机铃声。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.com/tags/随笔/"}]},{"title":"由零开始","date":"2016-07-24T10:56:14.000Z","path":"2016/07/24/由零开始/","text":"从凌晨一刻开始，我已经整整四个钟头没写一句话，洗手台下面的水管一直漏水，昨天我就发现了，也可能是前天，水就这么稀里里地流，我能想象它把房间充满，湿漉漉的被子死死压在身上，重得像这茫茫夜色的寂静，然而，除了夜什么也没发生。此时，房间另一边传来吱呀吱呀的声音，是突然侧身的室友，我急忙把手机屏亮起来，紧接着去床底下摸索出一盘蚊香，我想只有点上什么才能够逃脱，即使连一只蚊子也没有。 早上大概九点钟醒，一夜难眠，此刻兴致反倒高昂得紧，好像终于要开始什么伟大的事，毫不夸张地说，这股精神劲还是有生以来头一次。一切准备妥当，再去洗手台刮胡子，抹上一点肥皂水，尽量均匀些，不锈钢刀片沿上颚下巴来回律动着，欢快的节奏，如同远古深山里叮咚的清泉，不消尝一口，便已醉如泥泞。仿佛为了印证上述功效，室友一脸朦胧，以一个侧身盲点的位置伸手往床下探，约莫从他的鞋上晃三五次以后，我才恍然记起，他是在找袜子。十分钟前，我把房间重新整理了下，他的袜子作为房里最脏的东西之一，自然不能幸免，你可以想象得出，袜子是以怎样的痕迹从我手中落入垃圾娄，它简直是这个世界上最完美的抛物线，袜子对它饰演了这一杰作表示非常荣幸，所以正自鸣得意地待在垃圾娄的最底部。室友已经坐起来了，他蹙眉凝视，我想他已经很清楚了，他一直引以为傲的袜子，不存在了，但我没有因此同情他，反而我认为他表情转变得太过粗鲁，毕竟他只是为了印证功效才出现的。先不言他，此时我已经把胡子刮得一干二净，老实说，镜子里的这幅尊容比昨天不止漂亮上十倍，我讲这话的意思不是说昨天因为我外貌差了零点零一分而拒绝我的女孩今天就会接受我，我只是想陈述某件事实——我要出去面试了，因为零的倍数只可能是零，我始终不能靠脸吃饭。出门的时候，室友提醒我把垃圾也顺带扔了，我努了努嘴始终没有说话，我想，让一个人自己放弃一样东西很难，不如由他人代劳。 夏季的水泥路显然有些烫脚，我不得不以一个可笑的袋鼠跳的方式从树荫间穿过，原本并非一定要这样走，然而三食堂重新装修，这使得我必须再去找新的吃饭的地方，那儿步行的话将近有十分钟的路程。我想起两个月后到任的新承包商，他是原先二楼卖手抓饼的老板，对这个男人，并没多深刻的印象，看起来务实，矜矜业业。但很赏识老板娘，长相清秀，手艺精湛，会因为加了我不喜欢的香菜而重新做过，看得出来，她对她所从事职业的热爱，所以当我听说是她要承包整个食堂的时候，我第一个念头是，以后每个窗口都卖手抓饼。正是抱着这样的念头，我来到了正常营业的一食堂的门口。 里面人声鼎沸，只在门外，仿佛便有一种要被吞没的压迫感，各式各样的佐料味、汗味、本地产的廉价啤酒味、以及看起来格格不入的时尚女郎身上抹的香水味，它们像散发的彩虹的某一色光，在1q84小小人的带领下彼此厮杀着，然而又不能完全消灭，我看在眼里，却并未因此却步，再残酷也都要进去，都要吃饭。 等我打饭回来，并没直接去平时坐的座位，至于原因，那又是另一件事了。今天吃饭吃得比平时早了很多，虽然在时间上来说也不算早，但从我的生物钟看，它早得近乎异常。你要知道，这世上还有另一种人，他们享受孤独，只在人少的时候出没，像夜行的猫头鹰，敏锐、附有想象空间、又独具一格。我朝平日坐的位置看了两眼，然后选了它对面下一排的桌子，我就这样一边吃饭一边审视着对面那个座位。她妆容清秀，长头发，白色衬衣，没有破洞的蓝色牛仔裤，不过时的白底简约系带凉鞋，但是没有高跟，按鲁迅先生的原话，应该说标致极了，她安然霸占了我吃饭的宝地，以一种比我优雅多了的吃相被我审视着，我想，她究竟是迫于什么非要选择的这个位置。 要么她是同我一样类型的人物，首先不得不说那个位置在地理上已是绝佳——靠墙的一角，偏偏它对面的座位上还放着一顶迷彩军帽，不管出于什么，一般人都很难盯上这里，就连我，也是在连续使用洞察之眼的几回合后，才明白它正是为我这样注定成为王者的人而存在。所以当我第一次端着碗走向它的时候，我颤颤巍巍看了好久，从整个椅子的结构，到涂漆色泽，到颜料均匀度，连焊接口锈斑的小小瑕疵，都像是量身打造，无一不令人满意。我用手轻轻地去碰它，只在那一刹那，我发誓我被电到了，就像第一次牵心仪姑娘的手那样，电流从手的一端流经全身最后传到拿碗的那只手，在电流到达手指的零点零一秒内，我把碗筷放到了桌上，与其说放，不如说掉，我深怕因此而出名，这对于一个即将成为王者的人来说，是耻辱。碗筷放好，我把一只脚穿过桌子的承重架，另一只脚落在架子上，整个胯部被拉开一高一低，这样的姿势，让我有股学某种动物留下标志的冲动。考虑了约莫两分钟，才作罢，谁能凭爱意要富士山私有。当我马上就要找到什么词来形容我当时是如何把另一只脚放下的时候，不远处传来了玻璃酒瓶碎掉的声音。 不知你有没有遇过，因为你即将完成一件伟大的事，它看起来很近，却总是困难重重，我把这类事情归于命运的嫉妒。玻璃酒瓶碎了很明显属于此，《盗梦空间》里把音乐声当作梦醒的标志，它本身并不能唤醒任何人，它只是通知所有人你应该醒了。所以下一秒钟，我看到了令我排除以上假设——女孩与我同一类人的一幕。她略带惊恐地看向声源地，脚不自觉改变了所朝的方向，可能的话，她应该已经身处数米之外了。她是个爱看热闹的人，我马上下了如此的定论，这并非一只猫头鹰应禀有的天赋，它不过一场酒味小小人请求援军的闹剧。为此我只好重新思考有关她坐在那个位置的罪证。 曾经看过这么一部电影，女孩在恋人去世之后仍保持他存在着的记忆，比如，经常到小区附近的西餐厅点两份同样的意大利面，然而只吃一份；经常去学士路尽头的照相馆洗两份同样的生活照，却只拿走一份；经常从路过的某个未知名的零售店买两份同样的冰淇淋，而看着另一份融化。我一面否定女孩的行为，一面羡慕她的命运，她以一种近乎病态的爱来证明人们对于浪漫盲目般的憧憬，让每一代的俊男靓女前赴后继地追逐这个概率，满足一个情怀，或者寻找一种解脱。不管是什么，此时此刻，我已然把这顶帽子结结实实扣到眼前姑娘头上，是从她对面座位上拿的隶属于她已逝去恋人的帽子，她必须是这样的人，别无可能。吃完饭后，我悄然离开，我早该离开，甚至不该进来。 食堂前被赶出来的老头木箱里的啤酒只剩下几瓶，我看着从酒瓶瓶颈往下流的液化水汽，感觉天更热了。 原本想抄小路过桥快速到达公车站，途经清心亭的时候却被半个河面的莲花吸引，于是驻足拍了张照。我想起几日前从外面试回来时，有人问过荷花池在什么地方，当时含糊此处并无荷花云云，此刻见河中接天莲叶别样红，不禁抹了抹额角的细汗，一边还要骂上几句太阳的狠话。 过了李冰父子像就到了桥上，前面是干净的没有半根水草的河面，反倒是河沿的两侧满是半人高的芦苇，风沿着河面吹来，在芦苇倾斜间形成一股刺脸的热浪，而就在这一动一静之间，我看到不远处一个年轻的充满活力的垂钓者，之所以这么形容，是出于其对垂钓时间的把握，现在正是晌午，又哪里来的不怕热的鱼。转念一想，既然此刻有人站在这里看他钓，那这渔人也并非没有钓到鱼的可能，姜太公直钩尚且钓到周文王，就好像右边这十里荷花，没有开的时候，又有谁知道它的存在呢？ 一点二十二分下车，离约好面试的时间差三十八分钟，我没有直接去面试地点等，而是待在下车那个站台的后面的草坪一侧看书，看的是菲茨杰拉德的《人间天堂》,一直到一点五十四再去的面试处，期间公路的另一侧修剪草坪，这种大自然泥草的清新味道，只在原来割稻谷的时候闻到，而现在应该就是收割稻谷的时令了。我一边惶恐于自己的衣食无忧，一边没入林立的高楼大厦。 面试我的是个称得上漂亮的女人，面目清秀，身材匀称，头发整齐地落在肩上，流行的空气刘海因为长长有点黏住额角，言辞犀利，讲话时右手会把左手的食指握住，中指戴着一颗有点胖的金色转运珠，在手部的细微动作下格外引人注目。陆小凤说漂亮的女人最可怕，眼前的这位无疑就是一个，我们谈论了将近三个小时，之间我很怕因为她精湛的职场分析和层级的利诱技巧而改变来时的决议，索性我告诉她了，我只是想把最后一份简历送出去，我跟你们公司没什么仇，但我跟他们是两种人，而我不想变成他们。面试完毕后又聊了会儿，纯粹是消磨时光，听别人的故事，然后羡慕、嫉妒、或者同情，其实没什么两样，你依旧是这高级建材间的跳梁小丑，依旧做好本该悲哀者的觉悟。 一直拖到他们公司开会才离开，坐电梯下楼时差点从中途又出去，好在被人叫回来。沿公路外侧的人形道往回走，在第一个路口的支路向右转，我数着对面交通信号灯的秒数，整了整因为重新出汗而黏在背部的棉质衬衫。此时，太阳已经西沉，公交站的金属路牌上反射出季节的余热。 夜色降临的时候，我人在足球场地跑道上，我不知道跑了多少圈，只知道还没有虚脱。王小波说他总是不让自己闲起来，实在闲的时候就去外面跑步，这能有效避免手淫，我不排除这一功效，我跑步的原因是让自己虚脱，它能有效避免一切，包括思考。但是现在，显然没有达到这一效果。回来的时候，我点了一支烟，烟是六月中旬买的，芙蓉王，原本打算给投靠的同学抽，后来没有去，就一直留在书包里，已经将近一个月，烟只少了十分之一。我是个讨厌烟味的人，我告诉面试我的那个漂亮女人，我跟她解释，我讨厌的是那种吸入的烟的味道，不是烟本身，对我来说，烟草其实就和茶叶一样。我想起一句歌词“像我在往日还没抽烟”，很难想象，如今烟、酒竟成了愁绪的代名词，好像一拿起一支烟就是多么不开心一样，为什么要人为的去制造某种情绪的氛围，以此渲染肤浅的近似表演的戏剧色彩。我连续点了十八支烟，它们从此不再占用我的背包空间，不再有负重，连带着打火机也不用了，不听那些大道理，我依然可以过好这一生。 以上就是我他妈的漫长的一天。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.com/tags/随笔/"}]},{"title":"我为什么活着","date":"2016-07-14T18:11:30.000Z","path":"2016/07/15/我为什么活着/","text":"想写这篇文已经是几天之前，而真正开始动笔却是在这燥热的凌晨一点半。我想，人之所以还活着的理由，大概是为了反驳他的懒惰和一无是处。在我已完结的短暂生命里，有过爱恨，有过哀乐，有过离别与重逢，有过失望和期望，我以为我经历的已经是我的全部，而接下去的日子似乎变得无足轻重，开始在时间上堕落，就好像左手做了一件明知错误的事，右手却埋在深深的自责之中。我知道我沦落到了某个边缘之上，当我问自己你为什么而活的时候，我很诧异我究竟找不到什么确切的字眼形容。入夜的风同这无边的黑色一样，虽然不知道它确切地从哪里开始，到哪里结束，却一直真实存在着。 十五年前我刚上学，爷爷是在那年去世的，头七当天晚上，我们聚在未分家前的老屋子里折草纸冥具，等走完仪式，便按着曲折小路回实际的住处，路过一家废宅时，看到有零星的萤火虫熠熠飞过。那是七月份吧，大概只有七月份才会有萤火虫，夏季的晴晚，月光在银色系带中移过头顶。听到大伯谈姐姐的学习情况，说以后要和小叔一样做个文化人，那时姐姐成绩很好，她和小叔相差十五岁，十五年后她或许真的会成为文化人，那我呢？那我呢，我曾无数次从这间废宅走过，但我从来没想过十五年后我会成为什么样子，我只是好奇这间屋子的拥有者去哪里了，为什么破旧的门板上每年都会换新的对联。人总有某种归属感，活着的时候归属一间屋子，一间总是换着门联的废宅；死了，便归属坟墓，立一个碑，也要学活的时候搞个联子，做还活着的假象。 究竟为了什么而活着呢，或者说为什么活着才好呢，我想首先我得明白我，我想要什么，生活能给我什么，我又能改变什么。这些无非就是万事向前看的废话，因为到此为止你所获得的可能根本微不足道，甚至无所谓有无，在新的时间段里，它大多被遗忘，当你怀揣某种既定目标面向未来，希望能够得到一些有意义的回报，然后遇到一些人，又或者和一些人分开，然而，这些不过作为更远未来的过去又被遗忘，除此之外，便被胡乱记在歌词华丽的谎言里，“往事就像是一道桥，你我会过去的，情怀不会倒退”。 曾经我很信服村上在《挪》里写的“死不是生的对立面而作为生的一部分永存”，也因此会无缘故萌生一种自杀的冲动，我把心隔离在水银温度计的一端，总希冀有那么一个人能让我热到足以冲破禁锢，从那时起便有了恋人。当你喜欢什么人的时候，会觉得时光很短，剩下的日子都用来思念，而一旦想到死亡，便硬生生堕入虚无，怕从未留下什么证明你们爱过。令我没想到的是，恋人，并非一座桥而是一艘船，你始终在温度计里，只不过有了依靠，在飘摇里安定，在热血中平凡。或者，你会想，哪一天，你们结婚，有了小孩，抚育他们成人，尔后，苍老，从年华的景深中淡去。这时候，再记起王先生所作“况修短随化，终期于尽”的句子，“未尝不临文嗟悼，不能喻之于怀”。 死生向来同命运相关，而我又不是信命的人，很小时起就认为人应该是运命的，想来这亦是人类作为地球霸主屹立不倒的缘由之一，正是不同的命运和命运的交集缔造了不同的文明和文明的发展，事实上大部分人都是被命运奴役的，如同1984中所说“个人记忆被集体记忆掩盖”。一个人在自己记忆被忘却时能够怀疑自我的真实性，这是独立思考的基础，也是我活着另一个理由。我身边有太多这样的人——他老实、努力、很少犯错、生活规律——我只需见上一面就能看清他的未来。他所信任的不应该是真理部创造的，而是通过自我思考得到的，人存在的意义是为了给世界创出价值，而非其它生命，随历史的轮转消逝殆尽，我悟到了，那他们呢？ 这些年来，我一直如此苟活着，身边不停有人死去，每次母亲告诉我又有谁离世时，我没有一丝怜悯。这世上原本就有死生，那些曾经陪在身边的人，哪一天突然离开，这便是死，哪一天偶然重遇，这又是生，至于他是不是他，是死是生，已不重要，佛说，刹那即是永恒，一息便有轮回。 时间是永恒的参照，思维才是永恒，相对论中讲当速度等于光速，时间就会静止，超过光速，就能知晓未来，那过去呢，它被永远埋葬。人是思维的载体，它拥有思考这个方法，当他存在思维时，思考便作为一个永真式一直循环下去，每个人能都继承自这个类，重写它的思考方法，而以上便是我思考方法体的一部分。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.com/tags/随笔/"}]}]