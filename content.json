[{"title":"Shiro使用token实现单点登陆","date":"2019-03-12T16:16:23.000Z","path":"2019/03/13/shiro shi yong token shi xian dan dian deng lu/","text":"Shiro使用token实现单点登陆前后端分离，基于token实现认证登录。 ShiroFilter基本配置创建ShiroFilter1234567891011121314151617181920@Bean(\"shiroFilter\")public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean(); shiroFilter.setSecurityManager(securityManager); //oauth过滤 Map&lt;String, Filter&gt; filters = new HashMap&lt;&gt;(); filters.put(\"oauth2\", new OAuth2Filter()); shiroFilter.setFilters(filters); Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(\"/webjars/**\", \"anon\"); filterMap.put(\"/sys/login\", \"anon\"); filterMap.put(\"/**/*.css\", \"anon\"); filterMap.put(\"/**/*.js\", \"anon\"); filterMap.put(\"/**/*.html\", \"anon\"); filterMap.put(\"/**\", \"oauth2\"); shiroFilter.setFilterChainDefinitionMap(filterMap); return shiroFilter;&#125; Filter中设置路径匹配规则和securityManager securityManager1234567@Bean(\"securityManager\")public SecurityManager securityManager(OAuth2Realm oAuth2Realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(oAuth2Realm); return securityManager;&#125; securityManager中设置Realm认证器 Filter逻辑Filter实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class OAuth2Filter extends AuthenticatingFilter &#123; @Override protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception &#123; //获取请求token String token = getRequestToken((HttpServletRequest) request); if(StringUtils.isBlank(token))&#123; return null; &#125; return new OAuth2Token(token); &#125; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; return false; &#125; @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //获取请求token，如果token不存在，直接返回401 String token = getRequestToken((HttpServletRequest) request); if(StringUtils.isBlank(token))&#123; HttpServletResponse httpResponse = (HttpServletResponse) response; String json = new Gson().toJson(R.error(401, \"invalid token\")); httpResponse.getWriter().print(json); return false; &#125; return executeLogin(request, response); &#125; @Override protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; HttpServletResponse httpResponse = (HttpServletResponse) response; httpResponse.setContentType(\"application/json;charset=utf-8\"); try &#123; //处理登录失败的异常 Throwable throwable = e.getCause() == null ? e : e.getCause(); R r = R.error(401, throwable.getMessage()); String json = new Gson().toJson(r); httpResponse.getWriter().print(json); &#125; catch (IOException e1) &#123; &#125; return false; &#125; /** * 获取请求的token */ private String getRequestToken(HttpServletRequest httpRequest)&#123; //从header中获取token String token = httpRequest.getHeader(\"token\"); //如果header中不存在token，则从参数中获取token if(StringUtils.isBlank(token))&#123; token = httpRequest.getParameter(\"token\"); &#125; return token; &#125;&#125; token传参登录系统后，后台创建token返回给前端，前端存储，每次发送请求时带上token参数，或者统一配置到ajax的header中。后端统一使用getRequestToken获取token参数。 isAccessAllowed Filter拦截后，会调用isAccessAllowed方法，前后端分离模式下直接返回false。当isAccessAllowed返回true时，当前filter逻辑结束，整个filter链继续。返回false时，会调用onAccessDenied方法。 onAccessDenied当认证拒绝时，会执行AuthenticatingFilter的executeLogin方法 executeLogin123456789101112131415protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; AuthenticationToken token = createToken(request, response); if (token == null) &#123; String msg = \"createToken method implementation returned null. A valid non-null AuthenticationToken \" + \"must be created in order to execute a login attempt.\"; throw new IllegalStateException(msg); &#125; try &#123; Subject subject = getSubject(request, response); subject.login(token); return onLoginSuccess(token, subject, request, response); &#125; catch (AuthenticationException e) &#123; return onLoginFailure(token, e, request, response); &#125;&#125; getSubject方法会调用securityManager的createSubject创建一个Subject对象。执行Subject的login方法。login方法执行成功后执行onLoginSuccess回调，出现异常时执行onLoginFailure回调。 login12345public void login(AuthenticationToken token) throws AuthenticationException &#123; this.clearRunAsIdentitiesInternal(); Subject subject = this.securityManager.login(this, token); //...&#125; 调用securityManager的login方法。 123456789101112public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info; try &#123; info = this.authenticate(token); &#125; catch (AuthenticationException var7) &#123; //... &#125; Subject loggedIn = this.createSubject(token, info, subject); this.onSuccessfulLogin(token, info, loggedIn); return loggedIn;&#125; 调用authenticate方法，最终会调用ModularRealmAuthenticator的doAuthenticate方法 12345protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123; this.assertRealmsConfigured(); Collection&lt;Realm&gt; realms = this.getRealms(); return realms.size() == 1 ? this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken) : this.doMultiRealmAuthentication(realms, authenticationToken);&#125; 确保securityManager中设置了Realm，根据Realm的数量调用doSingleRealmAuthentication或者doMultiRealmAuthentication。 1234567891011121314protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) &#123; if (!realm.supports(token)) &#123; String msg = \"Realm [\" + realm + \"] does not support authentication token [\" + token + \"]. Please ensure that the appropriate Realm implementation is configured correctly or that the realm accepts AuthenticationTokens of this type.\"; throw new UnsupportedTokenException(msg); &#125; else &#123; AuthenticationInfo info = realm.getAuthenticationInfo(token); if (info == null) &#123; String msg = \"Realm [\" + realm + \"] was unable to find account data for the submitted AuthenticationToken [\" + token + \"].\"; throw new UnknownAccountException(msg); &#125; else &#123; return info; &#125; &#125;&#125; 当Realm的supports方法返回为true时，调用相应realm的getAuthenticationInfo方法。 1234567891011121314151617181920public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info = this.getCachedAuthenticationInfo(token); if (info == null) &#123; info = this.doGetAuthenticationInfo(token); log.debug(\"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo\", info); if (token != null &amp;&amp; info != null) &#123; this.cacheAuthenticationInfoIfPossible(token, info); &#125; &#125; else &#123; log.debug(\"Using cached authentication info [&#123;&#125;] to perform credentials matching.\", info); &#125; if (info != null) &#123; this.assertCredentialsMatch(token, info); &#125; else &#123; log.debug(\"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;]. Returning null.\", token); &#125; return info;&#125; 调用getCachedAuthenticationInfo获取缓存中的AuthenticationInfo，如果缓存中没有，调用doGetAuthenticationInfo方法。这个方法交由我们自己定义。 1234567891011121314151617181920protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String accessToken = (String) token.getPrincipal(); //根据accessToken，查询用户信息 SysUserToken tokenEntity = shiroService.queryByToken(accessToken); //token失效 if(tokenEntity == null || tokenEntity.getExpireTime().getTime() &lt; System.currentTimeMillis())&#123; throw new IncorrectCredentialsException(\"token失效，请重新登录\"); &#125; //查询用户信息 SysUser user = shiroService.queryUser(tokenEntity.getUserId()); //账号锁定 if(user.getStatus() == 0)&#123; throw new LockedAccountException(\"账号已被锁定,请联系管理员\"); &#125; SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, accessToken, getName()); return info;&#125; 根据token验证用户登录，如果验证通过，返回AuthenticationInfo，包含用户信息和当前token。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"shiro","slug":"shiro","permalink":"http://www.luofeng.tk/tags/shiro/"}]},{"title":"Springboot+logback日志系统","date":"2019-03-12T10:29:29.000Z","path":"2019/03/12/springboot logback ri zhi xi tong/","text":"Springboot+logback日志系统例子先贴例子，springboot中使用logback-spring.xml可以按照激活环境动态加载配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\" /&gt; &lt;conversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\" /&gt; &lt;conversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\" /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=\"CONSOLE_LOG_PATTERN\" value=\"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;\"/&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;/filter&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 开发、测试环境 --&gt; &lt;springProfile name=\"dev,test\"&gt; &lt;logger name=\"com.luofeng\" level=\"DEBUG\" additivity=\"false\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;/logger&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 生产环境 --&gt; &lt;springProfile name=\"prod\"&gt; &lt;property name=\"LOG_HOME\" value=\"d:/logs\" /&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/sys.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/sys-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件过滤INFO以下的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;logger name=\"com.luofeng\" level=\"INFO\" additivity=\"false\" &gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;/logger&gt; &lt;root level=\"error\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 基本标签property标签用于定义变量，包含name和value属性，使用时用${name}拼接 appender标签用来定义格式化日志输出，包含name和class属性，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。 root标签配置在根节点 configuration 下，必选节点，定义默认的日志信息，包含level属性，定义日志输出级别。level包含TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ，默认为DEBUG，大小写无关。 logger标签按照包或者具体类设置日志信息，包含name ，level和addtivity 属性。name指定包名或者类名；level同root的level属性一致；addtivity是指是否向上级logger传递打印信息，默认是true，当为true时，还会被匹配到的root再次输出一次。 springProfile标签配置激活环境下的logger设置，定义的springProfile的环境激活时，其下内容配置到 configuration 节点下，未激活时相当于注释了。包含name属性，配置激活环境。 具体配置一般来说只需要配置root标签，如果要按照包或类来输出不同格式或级别的日志，则需要配置logger标签。另外默认只有控制台输出，如果要定义文件日志输出，则需要定义单独的appender策略。在root和logger标签内使用appender-ref引用不同的策略。 定义控制台输出123456789&lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;debug&lt;/level&gt; &lt;/filter&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/layout&gt;&lt;/appender&gt; filter设置输出的级别，layout设置输出格式，layout可以用encoder代替，class要相应替换 定义文件输出RollingFileAppender标签文件策略使用 RollingFileAppender，按照日志日期，文件大小滚动生成日志文件。 file标签指定日志路径 encoder标签和layout标签类似，指定日志输出格式，可以通过charset指定输出文件的编码。 filter标签指定输出级别 rollingPolicy指定滚动策略 rollingPolicy标签日志记录器的滚动策略，按日期，按大小记录 fileNamePattern指定日志文件名的名称格式 timeBasedFileNamingAndTriggeringPolicy指定滚动策略，可以通过maxFileSize指定最大滚动文件大小 maxHistory指定文件存留时长","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"logback","slug":"logback","permalink":"http://www.luofeng.tk/tags/logback/"}]},{"title":"Ajax和springBoot传参收参","date":"2019-03-08T18:46:13.000Z","path":"2019/03/09/ajax he springboot chuan can shou can/","text":"Ajax和springBoot传参收参一般前台请求方式为get或post，后台收参形式为@RequestParam、@PathVariable和@RequestBody 前端get请求，后端@RequestParam收参Get请求时，参数跟在？后面，形式为key=value，多个参数间用&amp;连接，ajax有独立的get方法 123$.get(baseURL + \"sys/dict/qList?type=1\", function (r) &#123; //...&#125;); 后台接收 1234@RequestMapping(\"/qList\")public R qList(@RequestParam(required = false) String type)&#123; return R.ok().put(\"dictList\", sysDictService.queryAllList(type));&#125; 前端get请求，后端@PathVariable收参@PathVariable收参用于参数在请求url中，而不是在？后的参数部分 123$.get(baseURL + \"crm/customer/info/\"+id, function(r)&#123; //...&#125;); 后台接收 12345@RequestMapping(\"/info/&#123;id&#125;\")public R info(@PathVariable(\"id\") Long id)&#123; CrmCustomer crmCustomer = crmCustomerService.selectById(id); return R.ok().put(\"crmCustomer\", crmCustomer);&#125; 前端post请求，后端@RequestBody收参@RequestBody会把前端json字符串按照收参的类型强制转换，并按照json键和对象属性赋值，ajax请求时，type需指定为post，contentType需指定为application/json，data类型为json字符串，不能直接传json对象。 1234567891011saveOrUpdate: function () &#123; $.ajax(&#123; type: \"POST\", url: baseURL + \"crm/customer/save\", contentType: \"application/json\", data: JSON.stringify(vm.customer), success: function(r)&#123; //... &#125; &#125;);&#125;, 后台收参 123456@RequestMapping(\"/save\")public R save(@RequestBody CrmCustomer crmCustomer)&#123; ValidatorUtils.validateEntity(crmCustomer); crmCustomerService.insert(crmCustomer); return R.ok();&#125; 前端post请求，后端@RequestParam收参前端注意contentType修改为application/x-www-form-urlencoded，application/json无法通过@RequestParam收参。data直接传json对象，不能转成json字符串。 123456789101112131415161718var params = &#123; projectId:vm.project.id, groupId:groupId, ids:selectItems&#125;;$.ajax(&#123; type:\"POST\", url:baseURL+\"proj/expert/batchSave\", contentType:\"application/x-www-form-urlencoded\", data:params, success:function (r) &#123; if(r.code === 0)&#123; alert('操作成功'); &#125;else&#123; alert(r.msg); &#125; &#125;&#125;); 后台按照json对象的key来收参，@RequestParam用name或value属性指定对应的键值，键值为数组类型时，需要带上[]作为数组标记。 123456@RequestMapping(\"/batchSave\")public R batchSave(@RequestParam(name = \"projectId\") Long projectId, @RequestParam(name = \"groupId\") Long groupId, @RequestParam(name = \"ids[]\") List&lt;Long&gt; ids)&#123; //业务逻辑&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"ajax","slug":"ajax","permalink":"http://www.luofeng.tk/tags/ajax/"}]},{"title":"Springboot+MyBatis集成","date":"2019-02-19T16:29:21.000Z","path":"2019/02/20/springboot mybatis ji chen/","text":"Springboot+MyBatis集成首先我们知道MyBatis主要做持久层的工作，原始java开发中持久层，就是通过jdbc获取数据，然后解析赋值给相应的javaBean，这部分工作重复而且麻烦，mybatis要做的就是代替它们。 封装jdbc 完成sql和javaBean之间的映射 Springboot整合mybatis创建一个Springboot项目非常简单，要整合Mybatis做数据操作也很简单。 添加mybatis和数据库依赖，此处用mysql 123456789101112&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库连接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 配置数据源，yaml风格的配置方式 123456spring: datasource: url: jdbc:mysql://localhost:3306/test?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 创建一个实体User用来测试 User对象就两个属性，一个username，一个email，不贴了。 创建dao层接口 注意@Mapper注解和@Param注解，加上@Mapper注解才能被spring扫到，@Param用于标明是可以在sql中使用的参数，使用参数时用#{paramName}占位。 我们先用@Select注解直接查询测试一下。 12345678@Mapperpublic interface UserDao &#123; List&lt;User&gt; findList(); @Select(\"select * from sys_user where username = #&#123;name&#125;\") User findUserByName(@Param(\"name\") String username);&#125; 用Springboot环境直接测试接口 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class RestfulApiApplicationTests &#123; @Autowired private UserDao userDao; @Test public void contextLoads() &#123; User user = userDao.findUserByName(\"summer\"); System.out.println(user.toString()); &#125;&#125; 打印结果：`User{username=&apos;summer&apos;, email=&apos;luofeng.xia@test.com&apos;}` 说明到目前为止已经集成成功了，可以做简单的操作 通过mapper.xml中的sql语句实现数据操作 在resources下创建mapper文件夹，并创建UserDao.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.luofeng.study.restful.dao.UserDao\"&gt; &lt;select id=\"findList\" resultType=\"com.luofeng.study.restful.entity.User\"&gt; select * from sys_user &lt;/select&gt;&lt;/mapper&gt; namespace填写对应的dao层接口名，resultType填写返回的实体类名 添加mybatis配置 123mybatis: mapper-locations: classpath:/mapper/*Dao.xml type-aliases-package: com.luofeng.study.restful.entity mapper-locations 指定mapper文件的位置 type-aliases-package 指定类型别名的包，这里指定包名后，mapper里面直接写类名就可以。这里修改一下findList的resultType为User。 添加findList方法测试 1234567891011@Testpublic void contextLoads() &#123; User user = userDao.findUserByName(&quot;summer&quot;); System.out.println(user.toString()); List&lt;User&gt; list = userDao.findList(); for (User u : list) &#123; System.out.println(u.toString()); &#125;&#125; 结果当然没问题了，但是列表太长了，就意味着要分页了。 Springboot整合mybatis分页功能一般业务中查询数据时，除了分页外，还会包含数据条数，页数等数据，需要我们自行封装，此处只实现基础的分页功能，即sql中limit关键字功能 添加pagehelper分页插件 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 配置分页参数 yaml风格，比较简单 12345pagehelper: helperDialect: mysql offsetAsPageNum: true rowBoundsWithCount: true reasonable: true java风格 12345678910@Beanpublic PageHelper pageHelper() &#123; PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(\"offsetAsPageNum\", \"true\"); p.setProperty(\"rowBoundsWithCount\", \"true\"); p.setProperty(\"reasonable\", \"true\"); pageHelper.setProperties(p); return pageHelper;&#125; 更多参数和参数说明参考PageHelper官网 分页数据测试 123456789101112@Testpublic void contextLoads() &#123; User user = userDao.findUserByName(\"summer\"); System.out.println(user.toString()); PageHelper.startPage(1,5); List&lt;User&gt; list = userDao.findList(); for (User u : list) &#123; System.out.println(u.toString()); &#125;&#125; MybatisPlus升级更多功能","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.luofeng.tk/tags/mybatis/"}]},{"title":"Springboot后台http请求方案RestTemplate","date":"2019-02-13T18:11:11.000Z","path":"2019/02/14/springboot hou tai http RestTemplate/","text":"Springboot后台http请求方案RestTemplateRestTemplate是Spring为解决http请求建立的方案，对应包含了36个与REST资源交互的方法，其中的大多数都对应于HTTP的方法。 最为常用的是 getForEntity getForObject postForEntity postForObject **ForObject 是获取 **ForEntity 返回的数据部分，ForEntity响应中还包含header等信息，前缀的get和post分别表示请求方式。 Get请求三个重载方法 getForEntity(String url, Class responseType, Object… variables) url指定请求地址，responseType指定响应体的数据类型，variables可以传递请求参数 如果有额外的参数，在url中用占位符表示，例如?type={1}，那么variables的第一个参数就是{1} getForEntity(String url, Class responseType, Map variables) 额外参数用占位符?type={type}，map中以type为键put值进去，其它和上述一致 getForEntity(URI uri, Class responseType) 把参数以URI方式构建进去，Spring使用UriComponents来构建uri 案例测试先写一个后台接收请求，该方法可以接收一个param参数，打印后返回 12345@GetMapping(&quot;getSimpleTest&quot;)public R getSimpleTest(@RequestParam(required = false) String param)&#123; System.out.println(param); return R.ok(param);&#125; 无参请求测试 12345678@Testpublic void getForEntityTest()&#123; RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(\"http://localhost:8080/api/getSimpleTest\", String.class); System.out.println(responseEntity.getStatusCodeValue()); System.out.println(responseEntity.getHeaders().toString()); System.out.println(responseEntity.getBody());&#125; 测试结果： 123456请求后台打印：null测试打印：200&#123;Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Wed, 13 Feb 2019 09:29:05 GMT]&#125;&#123;&quot;msg&quot;:null,&quot;code&quot;:0&#125; 有参请求测试 123456789101112131415@Testpublic void getForEntityTest()&#123; //变长参数传递 ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(\"http://localhost:8080/api/getSimpleTest?param=&#123;1&#125;\", String.class,\"firstParam\"); System.out.println(responseEntity.getStatusCodeValue()); System.out.println(responseEntity.getHeaders().toString()); System.out.println(responseEntity.getBody()); //map参数传递 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"param\",\"mapParam\"); ResponseEntity&lt;String&gt; responseEntity1 = restTemplate.getForEntity(\"http://localhost:8080/api/getSimpleTest?param=&#123;param&#125;\", String.class,map); System.out.println(responseEntity1.getStatusCodeValue()); System.out.println(responseEntity1.getHeaders().toString()); System.out.println(responseEntity1.getBody());&#125; 测试结果： 12345678910请求后台打印：firstParammapParam测试打印：200&#123;Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Wed, 13 Feb 2019 09:43:41 GMT]&#125;&#123;&quot;msg&quot;:&quot;firstParam&quot;,&quot;code&quot;:0&#125;200&#123;Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Wed, 13 Feb 2019 09:43:41 GMT]&#125;&#123;&quot;msg&quot;:&quot;mapParam&quot;,&quot;code&quot;:0&#125; 中文乱码解决可能产生参数中文乱码，翻一下源码 123456789public RestTemplate() &#123; this.messageConverters = new ArrayList(); this.errorHandler = new DefaultResponseErrorHandler(); this.uriTemplateHandler = new DefaultUriBuilderFactory(); this.headersExtractor = new RestTemplate.HeadersExtractor(); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); //...&#125; StringHttpMessageConverter是直接new的，点击进去 123456public static final Charset DEFAULT_CHARSET;//...public StringHttpMessageConverter() &#123; this(DEFAULT_CHARSET);&#125; 再看下DEFAULT_CHARSET初始化 123static &#123; DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;&#125; 嗯，似乎找到原因了，我们只要把ISO_8859_1改成UTF_8就可以了 123RestTemplate restTemplate = new RestTemplate();//解决中文乱码restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); ForEntity和ForObjectgetForEntity返回一个ResponseEntity对象回来，T就是参数中responseType指定的类型，getForObject只返回T，其它和getForEntity一致。 Post请求post请求时，可以传递一个HttpEntity对象，其中可以包含自定义的Header，也可以直接传递数据参数 123456789101112131415161718192021222324@Testpublic void postForEntityTest()&#123; RestTemplate restTemplate = new RestTemplate(); //普通参数 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"param1\",\"param1\"); ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(\"http://localhost:8080/api/postSimpleTest\", map, String.class); System.out.println(responseEntity.getStatusCodeValue()); System.out.println(responseEntity.getHeaders().toString()); System.out.println(responseEntity.getBody()); //带header的参数 HttpHeaders headers = new HttpHeaders(); MediaType type = MediaType.parseMediaType(\"application/json; charset=UTF-8\"); headers.setContentType(type); headers.add(\"Accept\", MediaType.APPLICATION_JSON.toString()); JsonObject params = new JsonObject(); params.addProperty(\"headerParam\",\"这是一个自定义header的参数\"); HttpEntity&lt;String&gt; httpEntity = new HttpEntity&lt;&gt;(params.toString(), headers); ResponseEntity&lt;String&gt; responseEntity1 = restTemplate.postForEntity(\"http://localhost:8080/api/postSimpleTest\", httpEntity, String.class); System.out.println(responseEntity1.getStatusCodeValue()); System.out.println(responseEntity1.getHeaders().toString()); System.out.println(responseEntity1.getBody());&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"http","slug":"http","permalink":"http://www.luofeng.tk/tags/http/"}]},{"title":"springboot打包war和jar","date":"2019-02-01T19:59:42.000Z","path":"2019/02/02/springboot da bao war he jar/","text":"springboot打包war和jar用IDEA的 Spring Initializr 快速创建一个springboot 项目 项目目录很简单就不贴了，先看下pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.luofeng.study&lt;/groupId&gt; &lt;artifactId&gt;restful&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;restful-api&lt;/name&gt; &lt;description&gt;Demo project for RESTful-Api&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 默认打包方式是jar形式，所以 &lt;project&gt; 下没有 &lt;packaging&gt; 标签，更换为war包方式时， 在 &lt;project&gt; 标签下添加&lt;packaging&gt;war&lt;/packaging&gt; 修改原启动类继承自 SpringBootServletInitializer 重载 configure 方法 1234@Overrideprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(RestfulApiApplication.class);&#125; 更换maven仓库为aliyun的地址，在pom文件中添加以下配置 1234567&lt;repositories&gt; &lt;!--阿里云仓库--&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"}]},{"title":"Elasticsearch修改mapping","date":"2019-01-23T13:47:02.000Z","path":"2019/01/23/elasticsearch xiu gai mapping/","text":"Elasticsearch修改mapping我的场景需求是，ik在业务场景中分词歧义较多，导致搜索结果漏或者搜不到，因此需要更换分词器，就要修改mapping了，但是elasticsearch不支持直接修改mapping，因此需要另建索引然后转移数据。 假设原有索引是index1，type是test 新建索引index2 （url忽略） 1PUT index2 此时mapping为空，可以通过 GET index1 把原先mapping复制过来修改 12345678910111213141516171819202122232425262728293031323334353637383940GET index1&#123; &quot;index1&quot;: &#123; &quot;aliases&quot;: &#123;&#125;, &quot;mappings&quot;: &#123; &quot;test&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;store&quot;: true &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &#125; &#125; &#125;, ... &#125;&#125;POST index2/test/_mapping&#123; &quot;test&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;store&quot;: true &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;analyzer&quot;: &quot;smartcn&quot; &#125;, &#125; &#125;&#125; 把原有索引数据按照新索引重建 123456789POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;index1&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;index2&quot; &#125;&#125; 删除原索引，指定新索引别名为原索引名 123DELETE /index1POST /index2/_alias/index1","tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.luofeng.tk/tags/elasticsearch/"}]},{"title":"Springboot+Shiro 实现安全管理","date":"2019-01-14T15:21:15.000Z","path":"2019/01/14/springboot shiro shi xian an quan guan li/","text":"Springboot+Shiro 实现安全管理添加依赖，${shiro.version} 声明shiro的版本号12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;&lt;/dependency&gt; 注册 SecurityManager 和 ShiroFilterFactoryBeanShiroFilterFactoryBean类似于Servlet中的Filter，根据请求的url等来实现授权和鉴权。一般来说，针对数据api设置过滤，放行公共接口和静态资源。 1234567891011121314151617181920212223242526272829303132@Bean(\"shiroFilter\")public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean(); shiroFilter.setSecurityManager(securityManager); //oauth过滤 Map&lt;String, Filter&gt; filters = new HashMap&lt;&gt;(); filters.put(\"oauth2\", new OAuth2Filter()); shiroFilter.setFilters(filters); Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(\"/webjars/**\", \"anon\"); filterMap.put(\"/druid/**\", \"anon\"); filterMap.put(\"/api/**\", \"anon\"); filterMap.put(\"/sys/login\", \"anon\"); filterMap.put(\"/**/*.css\", \"anon\"); filterMap.put(\"/**/*.js\", \"anon\"); filterMap.put(\"/**/*.html\", \"anon\"); filterMap.put(\"/img/**\", \"anon\"); filterMap.put(\"/assets/**\", \"anon\"); filterMap.put(\"/fonts/**\", \"anon\"); filterMap.put(\"/plugins/**\", \"anon\"); filterMap.put(\"/swagger-resources/**\", \"anon\"); filterMap.put(\"/v2/**\", \"anon\"); filterMap.put(\"/favicon.ico\", \"anon\"); filterMap.put(\"/captcha.jpg\", \"anon\"); filterMap.put(\"/\", \"anon\"); filterMap.put(\"/**\", \"oauth2\"); shiroFilter.setFilterChainDefinitionMap(filterMap); return shiroFilter;&#125; 通过参数注入一个SecurityManager实例，创建一个自定义的Filter，按照需求配置过滤规则。Shiro自带的filter不贴了，anon 表示该url放行，优先级从上到下，所以此处用 LinkedHashMap ,除放行外，其余url全部走自定义的OAuth2Filter。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class OAuth2Filter extends AuthenticatingFilter &#123; @Override protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception &#123; //获取请求token String token = getRequestToken((HttpServletRequest) request); if(StringUtils.isBlank(token))&#123; return null; &#125; return new OAuth2Token(token); &#125; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; return false; &#125; @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //获取请求token，如果token不存在，直接返回401 String token = getRequestToken((HttpServletRequest) request); if(StringUtils.isBlank(token))&#123; HttpServletResponse httpResponse = (HttpServletResponse) response; String json = new Gson().toJson(R.error(401, \"invalid token\")); httpResponse.getWriter().print(json); return false; &#125; return executeLogin(request, response); &#125; @Override protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; HttpServletResponse httpResponse = (HttpServletResponse) response; httpResponse.setContentType(\"application/json;charset=utf-8\"); try &#123; //处理登录失败的异常 Throwable throwable = e.getCause() == null ? e : e.getCause(); R r = R.error(401, throwable.getMessage()); String json = new Gson().toJson(r); httpResponse.getWriter().print(json); &#125; catch (IOException e1) &#123; &#125; return false; &#125; /** * 获取请求的token */ private String getRequestToken(HttpServletRequest httpRequest)&#123; //从header中获取token String token = httpRequest.getHeader(\"token\"); //如果header中不存在token，则从参数中获取token if(StringUtils.isBlank(token))&#123; token = httpRequest.getParameter(\"token\"); &#125; return token; &#125;&#125; 每次非anno的请求都要经过OAuth2Filter，首先判断isAccessAllowed，这里把token非空判断提前，因此直接返回false，默认为true，且会执行executeLogin方法。返回false时调用onAccessDenied方法，这里面先判断token非空，非空则执行executeLogin 123456789101112131415protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; AuthenticationToken token = this.createToken(request, response); if (token == null) &#123; String msg = \"createToken method implementation returned null. A valid non-null AuthenticationToken must be created in order to execute a login attempt.\"; throw new IllegalStateException(msg); &#125; else &#123; try &#123; Subject subject = this.getSubject(request, response); subject.login(token); return this.onLoginSuccess(token, subject, request, response); &#125; catch (AuthenticationException var5) &#123; return this.onLoginFailure(token, var5, request, response); &#125; &#125; &#125; 根据请求的token参数，创建需要的AuthenticationToken对象，执行登陆操作，登陆成功执行onLoginSuccess回调，失败执行onLoginFailure回调。subject.login(token)方法中会按照Filter类型调用SecurityManager中相应Realm的方法。这里通过参数注入了一个自定义的OAuth2Realm给SecurityManager。 123456@Bean(\"securityManager\")public SecurityManager securityManager(OAuth2Realm oAuth2Realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(oAuth2Realm); return securityManager;&#125; #####OAuth2Realm实现认证和鉴权 除设置Realm外，SecurityManager 还可以设置SessionManager、RememberMeManager等其它属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class OAuth2Realm extends AuthorizingRealm &#123; @Autowired private ShiroService shiroService; @Override public boolean supports(AuthenticationToken token) &#123; return token instanceof OAuth2Token; &#125; /** * 授权(验证权限时调用) */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; SysUser user = (SysUser)principals.getPrimaryPrincipal(); Long userId = user.getUserId(); //用户权限列表 Set&lt;String&gt; permsSet = shiroService.getUserPermissions(userId); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setStringPermissions(permsSet); return info; &#125; /** * 认证(登录时调用) */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String accessToken = (String) token.getPrincipal(); //根据accessToken，查询用户信息 SysUserToken tokenEntity = shiroService.queryByToken(accessToken); //token失效 if(tokenEntity == null || tokenEntity.getExpireTime().getTime() &lt; System.currentTimeMillis())&#123; throw new IncorrectCredentialsException(\"token失效，请重新登录\"); &#125; //查询用户信息 SysUser user = shiroService.queryUser(tokenEntity.getUserId()); //账号锁定 if(user.getStatus() == 0)&#123; throw new LockedAccountException(\"账号已被锁定,请联系管理员\"); &#125; SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, accessToken, getName()); return info; &#125;&#125; supports方法表名当token类型是OAuth2Token下面的认证和授权方法才会生效。doGetAuthenticationInfo方法在每次请求时都会调用，确保当前token有效，并且把token对应的user信息丢给AuthenticationInfo返回回去。doGetAuthorizationInfo用来鉴权，包括权限和角色等，在@RequiresPermissions等注解请求时调用，返回当前user对应的permission和role等信息。 把ShiroFilter交给Spring管理要实现Filter功能，就要按照servlet规范实现Filter相应的方法，而Filter是归属于ServletContext的，无法享受Spring带来的遍历性，因此要用一个代理Filter。 1234567891011@Beanpublic FilterRegistrationBean shiroFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new DelegatingFilterProxy(\"shiroFilter\")); //生命周期由SpringApplicationContext管理 registration.addInitParameter(\"targetFilterLifecycle\", \"true\"); registration.setEnabled(true); registration.setOrder(Integer.MAX_VALUE - 1); registration.addUrlPatterns(\"/*\"); return registration;&#125; 首先注册一个Filter，这个Filter是一个代理Filter，实现由shiroFilter来完成。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"},{"name":"shiro","slug":"shiro","permalink":"http://www.luofeng.tk/tags/shiro/"}]},{"title":"前端中的日期时间选择组件","date":"2018-12-19T12:30:45.000Z","path":"2018/12/19/qian duan ri qi shi jian zu jian/","text":"前端中的日期时间选择组件涉及到三款组件，datepicker、datetimepicker和daterangepicker。datepicker是日期选择器，仅能选择日期，datetimepicker既可以选择日期也可以选择时间，daterangepicker用来选择时间范围，datepicker也可以选择范围，功能相对较少。 datepickerbootstrap-datepicker 是一个bootstrap样式的日期选择器，依赖Bootstrap 2.0.4+和jQuery 1.7.1+ 用法案例1&lt;input class=\"date-picker\" data-date-format=\"yyyy-mm-dd\" /&gt; 1234$('.date-picker').datepicker(&#123; autoclose: true,//选中后自动关闭选择器 todayHighlight: true//当天高亮&#125;); 其它配置用法参考官方文档，如果添加bootstrap-datepicker3.css将支持新的样式 ###datetimepicker bootstrap-datetimepicker 增加了Time支持和其它功能，除Bootstrap和jQuery外，还依赖 bootstrap-datetimepicker.css 和 moment.js 用法案例1&lt;input id=\"date-timepicker1\"/&gt; 1234567$('#date-timepicker1').datetimepicker(&#123; format:'YYYY-MM-DD HH:mm',//显示格式 keepOpen: true,//选择后自动关闭 defaultDate:new Date(),&#125;).on(\"dp.change\",function (e) &#123;//内容变化时调用，可以做赋值操作 vm.interview.startTime = e.date.format(\"YYYY-MM-DD HH:mm:ss\");&#125;); 更多用法参考官方文档 ，还有一个同名的组件，是基于datepicker的，用法和这个完全不一样，注意 daterangepickerdaterangepicker 支持日期时间范围，单日期时间等等，依赖 daterangepicker.css 和 moment.js 用法案例1&lt;input class=\"form-control\" type=\"text\" value=\"\" name=\"date-range-picker\"/&gt; 123456789101112131415161718192021222324252627282930$('input[name=date-range-picker]').daterangepicker(&#123; applyClass : 'btn-xs btn-success',//apply按钮样式 cancelClass : 'btn-xs btn-default',//cancel按钮样式 linkedCalendars: false, autoApply:false,//是否自动apply，自动填写就不会有apply等按钮了 autoUpdateInput:false,//初始值是否自动填写，选中后是否自动填写 showDropdowns:true,//显示单独的年/月选择 ranges: &#123;//快速范围过滤 'Today': [moment(), moment()], 'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')], 'Last 7 Days': [moment().subtract(6, 'days'), moment()], 'Last 30 Days': [moment().subtract(29, 'days'), moment()], 'This Month': [moment().startOf('month'), moment().endOf('month')], 'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')] &#125;, locale: &#123;//定制 format: 'YYYY-MM-DD',//显示格式 cancelLabel: 'Clear'//cancel按钮文字 &#125;&#125;);//绑定apply事件$('input[name=date-range-picker]').on('apply.daterangepicker', function(ev, picker) &#123; //给输入框按格式赋值 $(this).val(picker.startDate.format(picker.locale.format) + picker.locale.separator + picker.endDate.format(picker.locale.format));&#125;);//绑定cancel事件$('input[name=date-range-picker]').on('cancel.daterangepicker', function(ev, picker) &#123; //清除 $(this).val('');&#125;); 更多用法参考官方文档","tags":[{"name":"前端","slug":"前端","permalink":"http://www.luofeng.tk/tags/前端/"}]},{"title":"SpringBoot自我理解","date":"2018-09-15T16:09:13.000Z","path":"2018/09/16/springboot zi wo li jie/","text":"SpringBoot自我理解Spring框架的关键是DI（Dependency Injection）和AOP（Aspect-Oriented Programming），DI主要应用工厂模式，AOP应用代理模式，通过IoC（Inversion of Control）让对象之间解耦，对象和对象之间的依赖交由容器管理。 SpringMVC基于Spring，是针对web开发封装了一些常用组件和逻辑，例如安全、日志、事务等 SpringBoot基于SpringMVC并在配置上做了简化，提倡“约定大于配置”，把大多数系统的配置做了默认项，并且集成了Tomcat（Servlet容器），提供jar包和war包两种打包形式，使得web开发部署更简单高效。 SpringCloud一个微服务框架，它包含若干个Springboot应用，每个应用对应单个服务接口，SpringCloud串联了这一系列的应用接口。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.luofeng.tk/tags/springboot/"}]},{"title":"Jqgrid学习","date":"2018-07-12T18:59:33.000Z","path":"2018/07/13/jqgrid xue xi/","text":"Jqgrid学习初始化参数 jsonReader，设置了如何去解析从Server端传回来的json数据 123456789101112131415&#123; root: \"page.records\", // json中代表实际模型数据 page: \"page.current\", // json中代表当前页码 total: \"page.pages\", // json中代表总页码 records: \"page.total\", // json中代表数据总行数 repeatitems: true, // 如果设为false，则jqGrid在解析json时，会根据name来搜索对应的数据元素 cell: \"cell\", id: \"id\", userdata: \"userdata\", subgrid: &#123; root:\"rows\", repeatitems: true, cell:\"cell\" &#125; &#125; prmNames，设置了如何将Grid所需要的参数传给Server 12345678910111213141516&#123; page:\"page\", // 表示请求页码的参数名称 rows:\"rows\", // 表示请求行数的参数名称 sort: \"sidx\", // 表示用于排序的列名的参数名称 order: \"sord\", // 表示采用的排序方式的参数名称 search:\"_search\", // 表示是否是搜索请求的参数名称 nd:\"nd\", // 表示已经发送请求的次数的参数名称 id:\"id\", // 表示当在编辑数据模块中发送数据时，使用的id的名称 oper:\"oper\", // operation参数名称（我暂时还没用到） editoper:\"edit\", // 当在edit模式中提交数据时，操作的名称 addoper:\"add\", // 当在add模式中提交数据时，操作的名称 deloper:\"del\", // 当在delete模式中提交数据时，操作的名称 subgridid:\"id\", // 当点击以载入数据到子表时，传递的数据名称 npage: null, totalrows:\"totalrows\" // 表示需从Server得到总共多少行数据的参数名称&#125;","tags":[{"name":"jqgrid","slug":"jqgrid","permalink":"http://www.luofeng.tk/tags/jqgrid/"}]},{"title":"java maven gitignore","date":"2017-12-10T22:34:27.000Z","path":"2017/12/11/java maven gitignore/","text":"windows下创建.gitignore文件因为windows下 .后面的算作文件后缀，不能创建空文件名的文件，所以不能直接建.gitignore文件。可以在powershell命令行下，输入new-item .gitignore 创建.gitignore文件 gitignore文件模板对于一个maven项目来说，只要提交src、pom.xml、README.MD和.gitignore，其它文件容易造成冲突 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192### Java template*.class# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*### JetBrains template# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839# User-specific stuff:.idea/workspace.xml.idea/tasks.xml.idea/dictionaries.idea/vcs.xml.idea/jsLibraryMappings.xml# Sensitive or high-churn files:.idea/dataSources.ids.idea/dataSources.xml.idea/dataSources.local.xml.idea/sqlDataSources.xml.idea/dynamic.xml.idea/uiDesigner.xml# Gradle:.idea/gradle.xml.idea/# Mongo Explorer plugin:.idea/mongoSettings.xml## File-based project format:*.iws## Plugin-specific files:# IntelliJ/out/# mpeltonen/sbt-idea plugin.idea_modules/# JIRA pluginatlassian-ide-plugin.xml# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.propertiesfabric.properties### Windows template# Windows image file cachesThumbs.dbehthumbs.db# Folder config fileDesktop.ini# Recycle Bin used on file shares$RECYCLE.BIN/# Windows Installer files*.cab*.msi*.msm*.msp# Windows shortcuts*.lnk### Maven templatetarget/pom.xml.tagpom.xml.releaseBackuppom.xml.versionsBackuppom.xml.nextrelease.propertiesdependency-reduced-pom.xmlbuildNumber.properties.mvn/timing.properties# ignore eclipse files.project.classpath.settings.metadata","tags":[{"name":"Java","slug":"Java","permalink":"http://www.luofeng.tk/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"http://www.luofeng.tk/tags/Maven/"},{"name":"Git","slug":"Git","permalink":"http://www.luofeng.tk/tags/Git/"}]},{"title":"无关记事","date":"2017-11-25T17:26:38.000Z","path":"2017/11/26/wu guan ji shi/","text":"所谓孤独，就是哪怕周围再多人，感觉还是一个人。 冬季的早晨总是来得更晚，醒的时候，阳光已落进阳台。我想起朱自清先生的匆匆，想象那束光，是怎样在我不知觉时爬过窗台，爬过地砖间的缝隙。又想起验证地球自转的单摆实验，是怎样的摆针，怎样的沙盘，怎样地摆到现在。 我总以为一个人有了书，就会花时间去看，买了相机能很自然地出街，穿上新衣服便不再惧怕拍照，带着戒指意味着存在责任。然而，人终究被关在暗无天日里，没有无聊，便做些更无聊的事。或者突如其来地刷下装箱的旧鞋，或者躲在房间的角落，熄灭一支未尽的香烟。 多年未见的朋友突然来信，让人觉着生活仍是真实存在的，任你多想抛弃掉某些事实，它总能不经意间将你打醒。我在想，大抵我们之间已无恩怨，至于想不想交个新朋友，对现时的我来说，已无所谓有也无所谓无了。 十一月已到下旬，社交昵称总没再改，以前暗自庆幸的小把戏似乎显得幼稚。新的恋情自然向前，工作也不乏光彩。执笔时太阳已落到长河街的另一端，跟着去的，还有不绝的车流。单摆的摆针摆向明天，孤独将在明早的阳光中复现，毫不褪色。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]},{"title":"认识Servlet","date":"2017-11-22T22:30:48.000Z","path":"2017/11/23/Start Servlet/","text":"Servlet工作流 浏览器通过Request向服务器发起请求，具体请求某个servlet web容器调用Servlet的service方法，具体交给实现类的特定方法 Servlet处理完浏览器发来的请求之后，通过Response把结果返回 Servlet实现 Servlet是指javax.servlet.Servlet接口，默认定义了init、service、destroy等方法 其中init方法，在web容器实例化该servlet后调用一次，在init之后，这个servlet就被放入web服务中，只要当前服务不关，不管后续请求过多少次，都不会再调用。 service方法，真正处理浏览器请求的方法，在每次发起请求时都会被自动调用，接受一个ServletRequest和一个ServletResponse参数，分别封装了请求信息和响应信息。 destroy方法，与init方法对应，该方法在整个服务退出时被调用，调用后当前servlet无法再接收请求，意味着生命周期的结束。 GenericServlet是Servlet接口的实现类，需要自己重构Servlet时，一般从该类继承，也是Servlet类的鼻祖。 HttpServlet，继承自GenericServlet，是专门处理http协议的Servlet，其中定义了doGet和doPost，会根据http请求的方式自动调用，是最常用Serlter类。 第一个Servlet程序世界里，第一个永远是 Helloworld! 新建class，HelloworldServlet继承自HttpServlet，然后打印Hello World! 123456789101112131415161718import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloworldServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"Hello World!\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"Hello World!\"); &#125;&#125; 在web.xml中配置当前Servlet信息，其中servlet-name是给这个Servlet的唯一标识，通过标签和标签中的servlet-name字段，把前台url和后台调用的Servlet.class联系起来。 12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloworldServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloworldServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloworldServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloworld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注意 servlet-class是相对与当前web应用输出classes目录为根路径，默认为WEB-INF/classes/，因此如果是带包名的Servlet，这里的servlet-class也应该是全名。","tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://www.luofeng.tk/tags/Servlet/"}]},{"title":"B/S交互","date":"2017-11-20T23:19:16.000Z","path":"2017/11/21/BS Interaction/","text":"B/S交互概述B/S交互，无非是用户通过浏览器敲一个地址或者其它形式向服务器发起一个请求，或请求资源或发送指令，然后服务器根据浏览器发来的请求做逻辑处理，最后向浏览器返回一些结果。 HTTP协议协议就是一斤Apple五块钱，别人给你一斤苹果你不会给十块钱也不会给两块钱。HTTP协议就是浏览器和服务器之间交流的一种规则，这种规则规定了一系列的格式，但是这种规则是无连接的，在处理完一次Request-Response之后就会断开。 访问方式GET 和 POST 是最常用的访问方式，除此之外还有 HEAD、DELETE、TRACE、PUT、OPTIONS 5种访问方式 GET方式从浏览器地址栏输入网址，这种访问方式都是Get，Get方式的请求会把参数以key=value的形式带入到url中去，例如百度搜索Java，访问的链接就是http://www.baidu.com/s?wd=Java 并且Get方式提交的地址不能超过256(2的8次方)个字符。 POST方式一种场景是当请求的字符长度超过256个字符时，就必须使用Post方式，例如上传文件，还有一种是不想把敏感信息放入到url，例如密码信息，当然一般来说是不会有明文密码这种出现（通过协定好的加密解密方式）。Post方式一般要手动设置Content-Type和Content-Length，参数以键值对方式设置。 Java-Web中的实现首先明确的是，Java-Web中所有的Request-Response都是由 Servlet来完成的，Servlet是Java对于web交互的一种标准，而被web应用容器实现，例如 Tomcat，因此我们的web应用能够在这些容器中运行。一个Java程序应该是从main方法开始执行的，但是Servlet中没有main方法，而是在请求发送至服务端时，这些容器自动去调用Servlet中的某些方法。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.luofeng.tk/tags/HTTP/"},{"name":"Request-Response","slug":"Request-Response","permalink":"http://www.luofeng.tk/tags/Request-Response/"},{"name":"Java-Web","slug":"Java-Web","permalink":"http://www.luofeng.tk/tags/Java-Web/"}]},{"title":"web application基础知识","date":"2017-11-19T22:59:42.000Z","path":"2017/11/20/web application basic/","text":"web application一个符合标准的 web appliction 应该包含WEB-INF文件夹 该文件夹下必须包含web.xml文件 该文件的内容至少包含 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\" metadata-complete=\"true\"&gt;&lt;/web-app&gt; 它的目录层级应该是这样的，其中必要条件只有上述3个 1234567AppName WEB-INF web.xml lib（存放类库） classes（存放编译好的Class） META-INF（存放上下文信息，符合j2ee标准） other（存放其它的一些文件） 测试 在tomcat的webapps目录下创建test应用 按照上述标准在test目录下创建相应文件内容 在test目录下创建helloworld.html，内容为 Hello World! 启动tomcat 浏览器访问 http://127.0.0.1:8080/test/helloworld.html 浏览器上显示 Hello World! 其它 直接访问tomcat默认端口时，其实是访问名为webapps/ROOT这个应用 一般地，webapplication放在tomcat的webapps底下，访问时用默认地址端口/应用名 如果不放在webapps目录下，可以在tomcat/conf/server.xml的Host节点中添加节点，一个Context就相当于一个webapp。节点中的path指跟在tomcat默认端口后的访问路径，一定是以“/”开头，docBase指webapp的物理路径，可以是相对路径和绝对路径，其中相对路径是指与appBase（webapps）相对的路径。 1&lt;Context path=\"/hello\" docBase=\"D:\\ workspace\\hello\\WebRoot\" debug=\"0\" privileged=\"true\"/&gt;","tags":[{"name":"webapp","slug":"webapp","permalink":"http://www.luofeng.tk/tags/webapp/"},{"name":"tomcat","slug":"tomcat","permalink":"http://www.luofeng.tk/tags/tomcat/"}]},{"title":"春秋","date":"2017-01-14T20:56:15.000Z","path":"2017/01/15/chun qiu/","text":"长这么大，好像还是第一次进医院，不是什么大事，也有些心慌慌的，所谓初生牛犊不怕虎，大概如此。做过不少梦，幻想过许多美好的事，没来得及做或者做得更好。有一段时间，大脑像被抽成空白，然后疯狂地去补别人的故事，每逢过节，伪装成失落的恋人，在漆白的桦树林间偶遇谁，沿断桥的河岸线错过谁，从人群的雨伞下回望谁，让公车的玻璃窗画了谁，好像自己是每个故事的主角。我有点分裂，还是活着像个演员。原来就经常头痛，现在又多了胃痛，不知道肾好不好，神经衰弱，然后心理也有点抑郁，去办银行卡人家说我话都说不好不给我办，车也不会骑每次都变成别人的累赘。苟延残喘是一回事，要是被说没上进心是另一回事，被人收做妹妹也是另一回事。记得有一次是哪个假期，去看哪个同学的家人，同学是女同学，不确切是哪个，那个时候以为一定会记一辈子，没想到现在就忘了，那里和港口很近，过了一条街就是长堤，落日的余辉随波起伏，退潮的堤岸边被种上时令蔬菜，有游玩的情侣在互相拍照，身后是城市的音乐声，远方依旧是金鳞的水面，一望无际，货船只是呜呜向前。今天没事听起了半岛铁盒，它是一本书吗，如果是那去哪里买呢。某伦已经身为人父了，感谢在我的生命里有过他的演唱会。很庆幸当我睁开眼的时候，依然能看到你，白天，外面阳光灿烂，把自己关在开灯的房间里，季围巾戴帽子，不发出声音，就是来回走。我想，如果明天，我不再存在，请你记得，今天我喜欢过你。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]},{"title":"再见理想","date":"2016-10-24T08:53:07.000Z","path":"2016/10/24/zai jian li xiang/","text":"再见理想从九阳小店回去的时候，天就突然下起雨了，雨滴在门牌延伸的牛皮毡布上，噼啪噼啪的，像腊月深冬里的雪子，小店的砂锅气灶就摆在毡布下，沿街吹过的风，让幽紫色的火焰一闪一闪，沸腾溢出的汤水，在锈掉的金属灶具上滋一下就没了，老板忙着招呼客人，玻璃门内流出一股暖黄色的光，我到隔壁便利店买十块钱一包的烟，靠着墙根狭窄的干处往回走，路上浓密的墨点越来越重，小巷尽头，勾勒出农家枣树的稀疏掠影。 辗转数月，去过几个城市，见过不同地方的人。假如把自己置身世外，看广场上被俗世溜达的宠客，看晴晚远飞的流浪航班的警灯，看一群不知所云的方言嬉笑， 一个月了，知道所谓假如是没有假如的，我成了在城市街道上往来的实体，被运输工具置于生活与工作的两极。七点整，沿深巷往路口走，听到各式各样的闹铃，一边讥讽这些机械声线存在的意义，一边自豪着成为生物钟的异样光辉。晚上六点下班，城市的夜华灯初上，有些人的生活才刚刚开始，我钟情王菲唱的末班车，钟情夜色深处的暧昧红色。 雨下了好久，城市的桂树花开了又谢，撑一把黑色雨伞，去勤业路的便民超市买米，一辆私家车的前窗落满桂花花瓣，颜色很新，想来昨夜风雨严峻，自己却一无所知。最是人间留不住，下一句是什么。 时间是窗前一幢幢砖红色的屋顶，我数着数着的时候就真的失掉了，一开始还是秒、分钟、小时，后来就变成天、星期、月了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]},{"title":"Design设计","date":"2016-09-09T08:15:53.000Z","path":"2016/09/09/Android L New Design/","text":"Design设计在开发之前导入design包com.android.support:design，design包是跟随android5.0一起提出的，配合Material Design有非常好看的效果 TabLayout选项卡的标签布局，配合ViewPager使用，首先在XML布局文件中引入 1234567&lt;android.support.design.widget.TabLayout android:id=“@+id/tab” android:layout_width=“match_parent” android:layout_height=“wrap_content” … &gt;&lt;/android.support.design.widget.TabLayout&gt; TabLayout专有属性要在独立命名空间下，在布局文件的根布局下引入 xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; `&lt;/pre&gt; 这里署名为`app`，则在下面属性也要用`app`，下面是一些属性，标签文字的大小无法直接用`size`属性指定，只能用`tabTextAppearance`属性直接指定style样式 &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;5&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app:tabBackground=&quot;@color/colorPrimary&quot; //标签栏的背景&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabTextColor=&quot;@android:color/white&quot; //未选中标签文字的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabIndicatorColor=&quot;@android:color/white&quot; //滑块的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabSelectedTextColor=&quot;@color/colorAccent&quot; //选中标签文字的颜色&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;app:tabMode=&quot;scrollable&quot; //标签的模式，如果标签比较多时会跟随页面滚动&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; java代码中与ViewPager联动 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;5&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ViewPager pager = (ViewPager) findViewById(R.id.pager);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;TabLayout tab = (TabLayout) findViewById(R.id.tab);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;MyAdapter adapter=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyAdapter(getSupportFragmentManager(),list);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;pager.setAdapter(adapter);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;tab.setupWithViewPager(pager); &lt;span class=&quot;comment&quot;&gt;//在pager内容设置好后，设置与TabLayout的联动&lt;/span&gt;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; TabLayout标签上的文字来自于ViewPager，需要重写adapter的`getPageTitle()`方法 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;3&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CharSequence &lt;span class=&quot;title&quot;&gt;getPageTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; position)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list.get(position);&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; ## [](#DrawerLayout &quot;DrawerLayout&quot;)DrawerLayout 包括内容和抽屉(`NavigationView`)，可以选择覆盖toolbar或者跟toolbar联动，覆盖只需要把toolbar布局作为DrawerLayout内容的一部分，不覆盖则DrawerLayout应该在toolbar的下方，可以拥有抽屉的一个汉堡动画 ToolbarToolbar用来代替ActionBar可以更自由的摆放 1.backgruound属性用来指定toolbar的背景，theme属性用来指定整个主题，@style/ThemeOverlay.AppCompat.Dark.ActionBar&amp;quot;这个主题前景色是白色 1234567&lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” android:background=“@color/colorPrimary” android:layout_width=“match_parent” android:layout_height=“wrap_content” app:theme=“@style/ThemeOverlay.AppCompat.Dark.ActionBar”&gt;&lt;/android.support.v7.widget.Toolbar&gt; 2.在设置toolbar之前，应该先把程序原来的actionBar去掉，换NoActionBar的主题，例如Theme.AppCompat.Light.NoActionBar 3.在setContentView()方法之后，找到toolbar然后设置，setDisplayHomeAsUpEnabled()方法可以添加一个箭头图标，在有父Activity时能够返回 123Toolbar toolbar= (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar);getSupportActionBar().setDisplayHomeAsUpEnabled(true); NavigationView扮演抽屉导航中的抽屉，必须设置layout_gravity属性，代表向哪个方向滑动，特有属性也是在app命名空间下 1234567891011121314151617181920&lt;android.support.v4.widget.DrawerLayout android:id=“@+id/drawer” android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; &lt;LinearLayout android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; … &lt;/LinearLayout&gt; &lt;android.support.design.widget.NavigationView android:id=“@+id/nav” android:layout_gravity=“start” app:menu=“@menu/navigation” app:headerLayout=“@layout/header” app:itemTextColor=“@color/item_bg_select” app:itemIconTint=“@color/item_bg_select” android:layout_width=“match_parent” android:layout_height=“match_parent”&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 1.设置抽屉里的菜单 新建menu文件，group标签内的item是一组单选菜单，有选中和未选中之分，item-menu-item承接出来的菜单有子菜单的效果，会有一条横线隔开 12345678910111213141516171819202122232425&lt;?xml version=”1.0” encoding=”utf-8”?&gt;&lt;menu xmlns:android=“http://schemas.android.com/apk/res/android“&gt; &lt;group android:checkableBehavior=“single”&gt; &lt;item android:id=“@+id/single_1” android:icon=“@mipmap/ic_launcher” android:title=“单选1” /&gt; &lt;item android:id=“@+id/single_2” android:icon=“@mipmap/ic_launcher” android:title=“单选2” /&gt; &lt;/group&gt; &lt;item android:title=“子菜单”&gt; &lt;menu&gt; &lt;item android:id=“@+id/nav_item_1” android:icon=“@mipmap/ic_launcher” android:title=“菜单1” /&gt; &lt;item android:id=“@+id/nav_item_2” android:icon=“@mipmap/ic_launcher” android:title=“菜单2” /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 在NavigationView中配置app:menu属性，即上面的menu文件 2.设置抽屉里的header，显示用户的头像和用户名 新建header布局文件，写死header的高度，设置背景色，添加Imageview和Textview承载用户头像和名字 12345678910111213141516&lt;LinearLayout xmlns:android=“http://schemas.android.com/apk/res/android“ android:layout_width=“match_parent” android:layout_height=“200dp” android:gravity=“center” android:background=“@drawable/header_bg” android:orientation=“vertical”&gt; &lt;ImageView android:src=“@mipmap/ic_launcher” android:layout_width=“wrap_content” android:layout_height=“wrap_content” /&gt; &lt;TextView android:layout_marginTop=“16dp” android:layout_width=“wrap_content” android:layout_height=“wrap_content” android:text=“用户名”/&gt;&lt;/LinearLayout&gt; 在NavigationView中配置app:headerLayout属性，即上面的layout文件 3.设置抽屉的监听事件和与toolbar的联动 寻找到drawerlayout后利用ActionBarDrawerToggle对象控制toolbar上的图标与抽屉的联动 12345678910111213141516drawer = (DrawerLayout) findViewById(R.id.drawer);ActionBarDrawerToggle toggle=new ActionBarDrawerToggle(this, drawer,toolbar,0,0);drawer.addDrawerListener(toggle);toggle.syncState(); //同步状态 开或关给NavigationView添加监听事件，并重写监听回调nav.setNavigationItemSelectedListener(this);…public boolean onNavigationItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.nav_item_4: //事件处理 finish(); break; &#125; drawer.closeDrawer(GravityCompat.START); //每次点击后关闭抽屉 return true;&#125; SnackBar这个控件和Toast相似，出现位置是屏幕下方，可以给它添加动作，比如撤销，在CoordinatorLayout中可以配合侧滑删除 1234567Snackbar.make(view,“snackbar”,Snackbar.LENGTH_SHORT).setAction(“撤销”, new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; text.setVisibility(View.VISIBLE); text.animate().alpha(1); &#125; &#125;).show(); CoordinatorLayout继承自FrameLayout，在没有设置Behavior之前和帧布局无差，通过给它里面的控件设置Behavior可以达到不同的效果。 自定义Behavior 一系列的行为监听，当发生什么事情，应该做什么事情。给控件设置Behavior的方式有三种。 1.创建自定义Behavior类继承自系统的Behavior，重写onStartNestedScroll()方法和onNestedPreScroll()方法 1234567891011public class MyBehavior extends CoordinatorLayout.Behavior &#123; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return true; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, // TODU: &#125;&#125; 然后通过控件的LayoutParams设置 12CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) text.getLayoutParams();layoutParams.setBehavior(new MyBehavior()); 2.重写Behavior两个参数的构造方法 123public MyBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125; 在xml布局文件里给相应控件设置上layout_behavior属性 `app:layout_behavior=&quot;luofeng.study.com.app1.MyBehavior&quot; 3.第三个方法是在自定义控件时，利用注解框架绑定，参考FloatingActionButton AppBarLayoutAppBarLayout是对toolbar的在CoordinatorLayout上的外层嵌套，例如下滑隐藏，和悬停提示。如果是只要上滑就显示toolbar，把scrollFlags属性设置为enterAlways，如果要到滑动布局的最顶端再显示，则用enterAlwaysCollapsed 1234567891011121314151617&lt;android.support.design.widget.AppBarLayout android:layout_width=“match_parent” android:layout_height=“wrap_content” app:theme=“@style/ThemeOverlay.AppCompat.Dark.ActionBar”&gt; &lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” app:layout_scrollFlags=“scroll|enterAlwaysCollapsed”&gt; android:layout_width=”wrap_content” android:layout_height=”?actionBarSize”&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=“match_parent” android:layout_height=“wrap_content” android:text=“悬停条目”/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 这里需要注意的是，因为CoordinatorLayout是帧布局，在设置AppBarLayout后会遮住下面滚动布局的条目，可以通过修改它的layout_behavior属性避免。RecyclerView必须设置LayoutManager才可以使用 1234567&lt;android.support.v7.widget.RecyclerView android:id=“@+id/rv” android:layout_width=“match_parent” android:layout_height=“match_parent” app:layoutManager=“LinearLayoutManager” app:layout_behavior=“@string/appbar_scrolling_view_behavior”&gt;&lt;/android.support.v7.widget.RecyclerView&gt; CollapsingToolbarLayout可折叠的toolbar，是appbarLayout+toolbar的一种升级版，使用方法是在上面的toolbar上套一层CollapsingToolbarLayout布局，并把scollFlags属性移给它，修改值为exitUntilCollapsed，在下滑隐藏时会保留一个actionbar的位置 123456789101112131415161718&lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=“match_parent” android:layout_height=“wrap_content” app:contentScrim=“@color/colorPrimary” app:layout_scrollFlags=“scroll|exitUntilCollapsed”&gt; &lt;ImageView android:layout_width=“match_parent” android:layout_height=“160dp” app:layout_collapseMode=“parallax” android:src=“@mipmap/ic_launcher”/&gt; &lt;android.support.v7.widget.Toolbar android:id=“@+id/toolbar” android:layout_width=“wrap_content” android:layout_height=“?actionBarSize”&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 设置的ImageView可以有一个压缩的过程，CollapsingToolbarLayout的app:contentScrim是对压缩后的toolbar的遮蔽处理，通常设置为toolbar原来的颜色，imageview的app:layout_collapseMode属性指定了折叠模式，默认是向上推进，parallax是上下同时压缩。 FloatingActionButton浮动按钮，跟ImageButton最大的不同是，它和SnackBar处在同一层，它会因为SnackBar的show而升高，这也是它的名字的来由。它一般放置在AppBar的右下方 1234567&lt;android.support.design.widget.FloatingActionButton android:id=“@+id/fab” app:layout_anchor=“@id/appbar” app:layout_anchorGravity=“end|bottom” android:layout_width=“wrap_content” android:layout_height=“wrap_content” android:src=“@mipmap/ic_launcher”/&gt; FloatingActionButton的位置可以随意定，可以修改它的默认Behavior但是，重新设置后会覆盖原来的行为，因此，在使用时尽量去继承自具体的FloatingActionButton的Behavior类。 1234567&lt;android.support.design.widget.FloatingActionButton android:id=“@+id/fab” android:layout_gravity=“end|bottom” android:layout_width=“wrap_content” android:layout_height=“wrap_content” app:layout_behavior=“luofeng.study.com.app1.MyBehavior” android:src=“@mipmap/ic_launcher”/&gt; TextInputLayout文本输入布局，对输入文本有所优化，例如text提示，和基本的输入要求判断提示。使用时对EditText做一层包装 123456789&lt;android.support.design.widget.TextInputLayout android:id=“@+id/til” android:layout_width=“match_parent” android:layout_height=“wrap_content”&gt; &lt;EditText android:layout_width=“match_parent” android:layout_height=“wrap_content” android:hint=“用户名”/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 通过对EditText文本输入的监听，调用TextInputLayout相关方法提示 12textInput = (TextInputLayout) findViewById(R.id.til);extInput.getEditText().addTextChangedListener(this); 在输入文本时，会有一个错误提示 12345678public void afterTextChanged(Editable editable) &#123; if (editable.length()&lt;6) &#123; textInput.setError(“用户名不得少于6位”); textInput.setErrorEnabled(true); &#125;else &#123; textInput.setErrorEnabled(false); &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"http://www.luofeng.tk/tags/android/"},{"name":"笔记","slug":"笔记","permalink":"http://www.luofeng.tk/tags/笔记/"},{"name":"design","slug":"design","permalink":"http://www.luofeng.tk/tags/design/"}]},{"title":"android-async-http源码分析","date":"2016-08-24T23:02:15.000Z","path":"2016/08/25/android-async-http source analysis/","text":"android-async-http源码分析今天开始学习android-async-http的源码了 构造方法一共有五种构造方法，前三种都是调用这个有三个参数的，其余三个都是对这三个参数的其中几个或所有做固定赋值 12345678910/* Creates new AsyncHttpClient using given params @param fixNoHttpResponseException 是否通过忽略ssl认证自动修复连接无响应 @param httpPort http端口号 @param httpsPort https端口号*/public AsyncHttpClient(boolean fixNoHttpResponseException, int httpPort, int httpsPort) &#123; this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));&#125; 然而这个构造方法也没有具体实现，内部调用的是this(SchemeRegistry schemeRegistry)，getDefaultSchemeRegistry返回一个SchemeRegistry对象 12345678private static SchemeRegistry getDefaultSchemeRegistry(boolean fixNoHttpResponseException, int httpPort, int httpsPort) &#123; … SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme(“http”, PlainSocketFactory.getSocketFactory(), httpPort)); schemeRegistry.register(new Scheme(“https”, sslSocketFactory, httpsPort)); return schemeRegistry;&#125; 其实SchemeRegistry就是对这些协议的封装，利用map存了起来，http、https这些协议名称为key，具体的Scheme类就不看了 12345public final Scheme register(final Scheme sch) &#123; Args.notNull(sch, “Scheme”); final Scheme old = registeredSchemes.put(sch.getName(), sch); return old;&#125; 最后回到构造方法来，内部到底怎么实现的，好长，就是初始化了一些网络请求参数，然后线程池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public AsyncHttpClient(SchemeRegistry schemeRegistry) &#123; BasicHttpParams httpParams = new BasicHttpParams(); //默认的http请求参数 //设置httpParams参数的内容 ConnManagerParams.setTimeout(httpParams, connectTimeout); ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections)); ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS); HttpConnectionParams.setSoTimeout(httpParams, responseTimeout); HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout); HttpConnectionParams.setTcpNoDelay(httpParams, true); HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE); HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1); //协议版本 //线程安全的连接管理者 ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams); Utils.asserts(cm != null, “Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null”); threadPool = getDefaultThreadPool(); //得到一个线程池对象 //一个请求的map 封装了上下文和该上下文对应的请求的Handler的集合 该Handler用来管理一个请求 比如取消请求 requestMap = Collections.synchronizedMap(new WeakHashMap&lt;Context, List&lt;RequestHandle&gt;&gt;()); clientHeaderMap = new HashMap&lt;String, String&gt;(); //客户端请求头的一个map httpContext = new SyncBasicHttpContext(new BasicHttpContext()); //一个HttpClient对象 httpClient = new DefaultHttpClient(cm, httpParams); //添加一个请求拦截器，给请求Header添加gzip编码，替换重写的某些请求头参数 httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123; @Override public void process(HttpRequest request, HttpContext context) &#123; if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; //添加gzip编码 request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP); &#125; for (String header : clientHeaderMap.keySet()) &#123; //遍历所有的Header的键 if (request.containsHeader(header)) &#123; //如果请求Header里面包含这个键，就是说有自定义的Header参数 Header overwritten = request.getFirstHeader(header); //获得这个Header参数的值 log.d(LOG_TAG, String.format(“Headers were overwritten! (%s | %s) overwrites (%s | %s)”, header, clientHeaderMap.get(header), overwritten.getName(), overwritten.getValue()) ); //remove the overwritten header request.removeHeader(overwritten); //移除这个值 &#125; request.addHeader(header, clientHeaderMap.get(header)); //在相应键位上添加clientHeaderMap里的header参数 &#125; &#125; &#125;); //对响应做拦截，对gzip做解码 httpClient.addResponseInterceptor(new HttpResponseInterceptor() &#123; @Override public void process(HttpResponse response, HttpContext context) &#123; final HttpEntity entity = response.getEntity(); //获得内容 if (entity == null) &#123; return; &#125; final Header encoding = entity.getContentEncoding(); //获得编码方式 if (encoding != null) &#123; for (HeaderElement element : encoding.getElements()) &#123; if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) &#123; //为gzip编码 response.setEntity(new InflatingEntity(entity)); //解码之后重新设置内容 break; &#125; &#125; &#125; &#125; &#125;); //做认证的，暂时没看，和上面那个唯一不同的是，它排在拦截list的第0位，应该首先处理这个？？ httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123; … &#125;, 0); //设置重新请求 httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));&#125; get、post调用在new完对象之后，我们都是直接拿着去调get()、post()方法，下面就去看看，先看get()，一共有6个重载 123456789101112131415161718192021222324252627//1.只有url和响应接口，调用的重载4public RequestHandle get(String url, ResponseHandlerInterface responseHandler) &#123; return get(null, url, null, responseHandler);&#125;//2.加上一个params请求参数，调用重载4，经常用这个public RequestHandle get(String url, RequestParams params, ResponseHandlerInterface responseHandler) &#123; return get(null, url, params, responseHandler);&#125;//3.没有params，但是多一个context，调用重载4public RequestHandle get(Context context, String url, ResponseHandlerInterface responseHandler) &#123; return get(context, url, null, responseHandler);&#125;//4.调用sendRequest()方法public RequestHandle get(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), null, responseHandler, context);&#125;//5.设置传入的header再调用sendRequest()public RequestHandle get(Context context, String url, Header[] headers, RequestParams params, ResponseHandlerInterface responseHandler) &#123; HttpUriRequest request = new HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)); if (headers != null) request.setHeaders(headers); return sendRequest(httpClient, httpContext, request, null, responseHandler, context);&#125;//6.use this to send string/json/xml，然后再调用sendRequest()方法public RequestHandle get(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpGet(URI.create(url).normalize()), entity), contentType, responseHandler, context);&#125; 最终调用都是sendRequest()，而且方法是有返回值的，类型是RequestHandler，这个类好像在哪里见过，没错就是这 requestMap = Collections.synchronizedMap(new WeakHashMap&amp;lt;Context, List&amp;lt;RequestHandle&amp;gt;&amp;gt;());在AsyncHttpClient的构造方法里，我们创建了这么一个map，里面存着以Context为键泛型为RequestHandler的list集合。再看一眼post方法 123public RequestHandle post(Context context, String url, HttpEntity entity, String contentType, ResponseHandlerInterface responseHandler) &#123; return sendRequest(httpClient, httpContext, addEntityToRequestBase(new HttpPost(getURI(url)), entity), contentType, responseHandler, context);&#125; 嘿嘿，果然和get方法一样，最后都是调用sendRequest()，返回值也都是RequestHandler对象。先看sendRequest() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* put一个新请求到线程池的执行队列里 @param client 就是构造方法里初始化的一个DefaultHttpClient @param contentType MIME body type，may be null，某些get、put方法里有这个参数 @param context Android上下文，持有这个request请求，为了cancel() @param httpContext HttpContext in which the request will be executed @param responseHandler 处理响应的接口 @param uriRequest 必须是HttpUriRequest的实例，封装了url和请求参数等等 /protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) &#123; //uriRequest必须非空 if (uriRequest == null) &#123; throw new IllegalArgumentException(“HttpUriRequest must not be null”); &#125; //responseHandler必须非空 if (responseHandler == null) &#123; throw new IllegalArgumentException(“ResponseHandler must not be null”); &#125; //异步请求里面不能使用同步响应处理 if (responseHandler.getUseSynchronousMode() &amp;&amp; !responseHandler.getUsePoolThread()) &#123; throw new IllegalArgumentException(“Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.”); &#125; //设置自定义的contentType if (contentType != null) &#123; if (uriRequest instanceof HttpEntityEnclosingRequestBase &amp;&amp; ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != null &amp;&amp; uriRequest.containsHeader(HEADER_CONTENT_TYPE)) &#123; log.w(LOG_TAG, “Passed contentType will be ignored because HttpEntity sets content type”); &#125; else &#123; uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType); &#125; &#125; //确保以上这些都检查完并设置好之后，把uriRequest的一些参数复制给responseHandler一份 responseHandler.setRequestHeaders(uriRequest.getAllHeaders()); responseHandler.setRequestURI(uriRequest.getURI()); //创建一个AsyncHttpRequest对象，把这个对象添加到线程池的执行队列中，创建一个RequestHandler对象 AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context); threadPool.submit(request); RequestHandle requestHandle = new RequestHandle(request); //context不为空，把上面的requestHandler放到Map中去 if (context != null) &#123; List&lt;RequestHandle&gt; requestList; // Add request to request map synchronized (requestMap) &#123; requestList = requestMap.get(context); if (requestList == null) &#123; requestList = Collections.synchronizedList(new LinkedList&lt;RequestHandle&gt;()); requestMap.put(context, requestList); &#125; &#125; requestList.add(requestHandle); //遍历集合，如果发现有requestHandler对应的request已经消费完，则移除当前requestHandler Iterator&lt;RequestHandle&gt; iterator = requestList.iterator(); while (iterator.hasNext()) &#123; if (iterator.next().shouldBeGarbageCollected()) &#123; iterator.remove(); &#125; &#125; &#125; return requestHandle; //返回requestHandle&#125; 这里知道我们所有的请求最后都被封装到了AsyncHttpRequest，然后把它交给了线程池，然后再处理了下RequestHandler，并返回，下面看看这个RequestHandler 1234567891011121314151617181920212223242526272829303132333435public class RequestHandle &#123; private final WeakReference&lt;AsyncHttpRequest&gt; request; public RequestHandle(AsyncHttpRequest request) &#123; this.request = new WeakReference&lt;AsyncHttpRequest&gt;(request); &#125; //用于取消当前request，就算返回true也并不一定是真的取消成功了，只是尝试去取消 public boolean cancel(final boolean mayInterruptIfRunning) &#123; final AsyncHttpRequest _request = request.get(); if (_request != null) &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; _request.cancel(mayInterruptIfRunning); &#125; &#125;).start(); return true; &#125; else &#123; return _request.cancel(mayInterruptIfRunning); &#125; &#125; return false; &#125; //如果当前request被取消了或者完成了，则把当前request对象=null，不是引用，而是里面包裹的AsyncHttpRequest public boolean shouldBeGarbageCollected() &#123; boolean should = isCancelled() || isFinished(); if (should) request.clear(); return should; &#125; …&#125; 它持有一个AsyncHttpRequest对象，这个是在构造方法里面传入的，并且通过弱引用包裹，与上面的sendRequest()方法结合起来就是，在我们调用get()、post()方法发送请求时，它会把我们的一系列请求参数封装，作为一个Request对象扔给了线程池的待执行队列，然后创建一个持有当前Request对象的RequestHandler，并返回给调用者。请求的步骤大概就是这样。 开始异步请求首先，AsyncHttpRequest实现了Runnable接口，现在先看看构造方法 123456public AsyncHttpRequest(AbstractHttpClient client, HttpContext context, HttpUriRequest request, ResponseHandlerInterface responseHandler) &#123; this.client = Utils.notNull(client, “client”); this.context = Utils.notNull(context, “context”); this.request = Utils.notNull(request, “request”); this.responseHandler = Utils.notNull(responseHandler, “responseHandler”);&#125; 就是判断了一下参数是否为空然后赋值，下面就去看它的run方法 12345678910111213141516171819202122232425262728293031323334public void run() &#123; //判断是否取消了，取消则直接返回 if (isCancelled()) &#123; return; &#125; // 判断该Request是否已经准备执行，避免多次执行请求 if (!isRequestPreProcessed) &#123; isRequestPreProcessed = true; onPreProcessRequest(this); &#125; //给调用者发送一个准备开始的消息 responseHandler.sendStartMessage(); try &#123; //开始请求并尝试重新请求 makeRequestWithRetries(); &#125; catch (IOException e) &#123; if (!isCancelled()) &#123; //没有被取消就发送错误消息 responseHandler.sendFailureMessage(0, null, null, e); &#125; else &#123; AsyncHttpClient.log.e(“AsyncHttpRequest”, “makeRequestWithRetries returned error”, e); &#125; &#125; //发送完成消息 responseHandler.sendFinishMessage(); … //设置完成状态 isFinished = true;&#125; 开始请求前给调用者发送了一个开始的消息，然后开始请求，如果请求出错，发送了一个错误的消息，完成后也发送了一个完成的消息，这是整个流程，下面来看看，它是怎么请求的 123456789101112private void makeRequestWithRetries() throws IOException &#123; boolean retry = true; //在AsyncHttpClient的构造方法里我们设置了这么一个东东 HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler(); try &#123; while (retry) &#123; try &#123; makeRequest(); //终于要发送请求了吗 return; &#125; …各种捕获异常，抛异常&#125; 好像还是没有开始请求，接着往里面看 123456789101112131415private void makeRequest() throws IOException &#123; … // 做了下判断，更新Header if (responseHandler instanceof RangeFileAsyncHttpResponseHandler) &#123; ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request); &#125; // 真正的请求在这里 HttpResponse response = client.execute(request, context); … // 发送了一个处理的消息 responseHandler.sendResponseMessage(response); …&#125; 真正的请求开始了，虽然还没见着方法体，可以看到这里根据传入的responseHandler的不同，要做一个响应Header的处理，然后开始请求，然后把返回的response交给responseHandler做响应处理，怎么处理等会儿再看，把request看完先 123456public CloseableHttpResponse execute( final HttpUriRequest request, final HttpContext context) throws IOException, ClientProtocolException &#123; Args.notNull(request, “HTTP request”); return doExecute(determineTarget(request), request, context);&#125; 这个execute是CloseableHttpClient的方法，我们传入的client是它的子类的一个实例，它又调用了doExecute()方法，继续看 12protected abstract CloseableHttpResponse doExecute(HttpHost target, HttpRequest request, HttpContext context) throws IOException, ClientProtocolException; 果然，这是一个抽象类，到底怎么doExecute交给具体的子类实现，下面去找它的实现，在AbstractHttpClient里面找到了这个方法 123456try &#123; out = CloseableHttpResponseProxy.newProxy( director.execute(target, request, execContext)); &#125; catch … return out; 不知道我费劲心思想找这个发送请求的方法干嘛，它又转移了，偷偷瞄了一眼这个execute方法，好长，吓得我赶紧退了回来，具体的怎么请求其实不需要太了解，反正也看不懂，就是一系列封装，最后返回这个out，也就是请求网络完成后的响应， 响应处理现在就来看处理响应的ResponseHandler了 中间代码不贴了ResponseHandler其实是一个接口，封装了响应之后各个阶段的方法，而且框架已经帮我们写了很多实现类，比如常用的AsyncHttpResponseHandler、DataAsyncHttpResponseHandler、TextHttpResponseHandler、JsonHttpResponseHandler、FileAsyncHttpResponseHandler，所以用不着我们自己去实现，针对每种不同的请求方式，这些类会自动做相关的处理，比如请求获得一个文件，会在处理response的时候，直接返回一个file对象，下面来看看AsyncHttpResponseHandler，它是其它几个常用实现类的父类 123456789101112131415161718192021222324252627282930313233// 1.不带参数，一般我们get、post时候就是用这个，匿名对象public AsyncHttpResponseHandler() &#123; this(null);&#125;// 2.第一个构造方法其实就是调用的这个，然后调用第4个构造方法public AsyncHttpResponseHandler(Looper looper) &#123; // 默认使用主线程的Looper this(looper == null ? Looper.myLooper() : looper, false);&#125;// 3.可以手动指定使用线程池所在线程？不一定对，应该是当前Request所在的线程，即同步响应public AsyncHttpResponseHandler(boolean usePoolThread) &#123; this(usePoolThread ? null : Looper.myLooper(), usePoolThread);&#125;// 4.其它构造方法都是调用这个，而这个构造方法是private的// 如果同步响应，loop必须为空，异步响应，loop必须是Looper.myLooper()，而且usePoolThread必定为falseprivate AsyncHttpResponseHandler(Looper looper, boolean usePoolThread) &#123; if (!usePoolThread) &#123; // 异步响应时，初始化了handler对象 Utils.asserts(looper != null, “use looper thread, must call Looper.prepare() first!”); this.looper = looper; this.handler = new ResponderHandler(this, looper); &#125; else &#123; // 如果同步响应，全部置空 Utils.asserts(looper == null, “use pool thread, looper should be null!”); this.looper = null; this.handler = null; &#125; this.usePoolThread = usePoolThread;&#125; 在上面初始化Handler的时候，发现是new了一个ResponderHandler对象，下面去看看它 12345678910111213141516/* Avoid leaks by using a non-anonymous handler class. */private static class ResponderHandler extends Handler &#123; private final AsyncHttpResponseHandler mResponder; ResponderHandler(AsyncHttpResponseHandler mResponder, Looper looper) &#123; super(looper); this.mResponder = mResponder; &#125; @Override public void handleMessage(Message msg) &#123; mResponder.handleMessage(msg); &#125;&#125; 先看它的注释，通过使用一个非匿名的Handler类来避免泄漏，唉，看别人写的代码就是享受呀，静态内部类，学到了。再看它的实现，把handleMessage方法交给外面的AsyncHttpResponseHandler去处理，下面看看怎么处理的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Methods which emulate android’s Handler and Message methodsprotected void handleMessage(Message message) &#123; Object[] response; try &#123; // 根据收到的消息，调用相关的回调 switch (message.what) &#123; case SUCCESS_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 3) &#123; onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “SUCCESS_MESSAGE didn’t got enough params”); &#125; break; case FAILURE_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 4) &#123; onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “FAILURE_MESSAGE didn’t got enough params”); &#125; break; case START_MESSAGE: onStart(); break; case FINISH_MESSAGE: onFinish(); break; case PROGRESS_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length &gt;= 2) &#123; try &#123; onProgress((Long) response[0], (Long) response[1]); &#125; catch (Throwable t) &#123; AsyncHttpClient.log.e(LOG_TAG, “custom onProgress contains an error”, t); &#125; &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “PROGRESS_MESSAGE didn’t got enough params”); &#125; break; case RETRY_MESSAGE: response = (Object[]) message.obj; if (response != null &amp;&amp; response.length == 1) &#123; onRetry((Integer) response[0]); &#125; else &#123; AsyncHttpClient.log.e(LOG_TAG, “RETRY_MESSAGE didn’t get enough params”); &#125; break; case CANCEL_MESSAGE: onCancel(); break; &#125; &#125; catch (Throwable error) &#123; onUserException(error); &#125;&#125; 第一句的注释意思是，我就模仿Android的Handler来处理消息，根据发送消息的what判断，去调用相关的回调，从start到finish()全部都有，这些消息在什么时候发的呢，在开始的sendRequest的一系列过程中都有所体现，success和failure的消息稍微有点隐晦，是在sendResponseMessage方法中处理的 123456789101112131415public void sendResponseMessage(HttpResponse response) throws IOException &#123; // 如果请求被cancel掉了就不做处理 if (!Thread.currentThread().isInterrupted()) &#123; StatusLine status = response.getStatusLine(); byte[] responseBody; responseBody = getResponseData(response.getEntity()); if (!Thread.currentThread().isInterrupted()) &#123; if (status.getStatusCode() &gt;= 300) &#123; sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase())); &#125; else &#123; sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody); &#125; &#125; &#125;&#125; responseBody从getResponseData()方法中得到，根据响应码的值判断是否成功，发送相应的消息出去，至此为止好像还有一个回调没有发消息，onProgress()，下面来看看 12345678910111213141516171819202122232425262728293031323334byte[] getResponseData(HttpEntity entity) throws IOException &#123; byte[] responseBody = null; if (entity != null) &#123; InputStream instream = entity.getContent(); if (instream != null) &#123; long contentLength = entity.getContentLength(); //获得响应内容的长度 if (contentLength &gt; Integer.MAX_VALUE) &#123; throw new IllegalArgumentException(“HTTP entity too large to be buffered in memory”); &#125; int buffersize = (contentLength &lt;= 0) ? BUFFER_SIZE : (int) contentLength; try &#123; ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize); try &#123; byte[] tmp = new byte[BUFFER_SIZE]; long count = 0; int l; while ((l = instream.read(tmp)) != -1 &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; count += l; buffer.append(tmp, 0, l); sendProgressMessage(count, (contentLength &lt;= 0 ? 1 : contentLength)); &#125; &#125; finally &#123; AsyncHttpClient.silentCloseInputStream(instream); AsyncHttpClient.endEntityViaReflection(entity); &#125; responseBody = buffer.toByteArray(); &#125; catch (OutOfMemoryError e) &#123; System.gc(); throw new IOException(“File too large to fit into available memory”); &#125; &#125; &#125; return responseBody;&#125; sendProgressMessage()在while循环里调用了，循环条件中加了一个是否cancel，如果被取消就没必要再发消息了，finally里面关流，并且把响应内容toByteArray()返回，那么异步响应到此为止全部结束，下面看看同步响应 123456789101112131415161718public void setUseSynchronousMode(boolean sync) &#123; // A looper must be prepared before setting asynchronous mode. if (!sync &amp;&amp; looper == null) &#123; sync = true; AsyncHttpClient.log.w(LOG_TAG, “Current thread has not called Looper.prepare(). Forcing synchronous mode.”); &#125; // If using asynchronous mode. if (!sync &amp;&amp; handler == null) &#123; // Create a handler on current thread to submit tasks handler = new ResponderHandler(this, looper); &#125; else if (sync &amp;&amp; handler != null) &#123; // TODO: Consider adding a flag to remove all queued messages. handler = null; &#125; useSynchronousMode = sync;&#125; sync的值是设置进来的，假设为false，那么就是说我希望是异步响应，然而你的looper为空，所以不可能异步，就强制设置回true。其实想想，looper什么情况下可能为null，那就是在构造方法里传入usePoolThread为true的时候，也就是说刚好也设为同步。如果传入的是true，那就没话说，最后也把mod设置为同步。那么同步mod下怎么处理 12345678protected void sendMessage(Message msg) &#123; if (getUseSynchronousMode() || handler == null) &#123; handleMessage(msg); &#125; else if (!Thread.currentThread().isInterrupted()) &#123; // do not send messages if request has been cancelled Utils.asserts(handler != null, “handler should not be null!”); handler.sendMessage(msg); &#125;&#125; 嘿嘿，只能说设计得太巧妙了，如果是同步模式下，直接处理消息，异步模式才会用handler去发消息，该回调还是回调，但是同步模式下，不能直接更新ui，切记 总结一下AsyncHttpClient核心类AsyncHttpRequest+RequestHandler请求和请求管理ResponseHandler+子类实现+setMod可以同步/异步响应技术要点： 线程池，AsyncHttpRequest实现Runnable接口，添加到线程池执行队列中 AsyncResponseHandler的异步响应，运用了android中的Handler ResponseHandler是一个接口，针对接口编程，扩展性更强","tags":[{"name":"android","slug":"android","permalink":"http://www.luofeng.tk/tags/android/"},{"name":"笔记","slug":"笔记","permalink":"http://www.luofeng.tk/tags/笔记/"},{"name":"源码","slug":"源码","permalink":"http://www.luofeng.tk/tags/源码/"}]},{"title":"瞎子","date":"2016-08-12T22:21:01.000Z","path":"2016/08/13/xia zi/","text":"下午四点二十八分的时候，我接了一个电话，在此之前，我漠视了许多通同一区号的号码，我不知道我接它的理由，只听到聚氯乙烯包裹下的性感女声：“先生，马上要七夕了，你要带着黑眼圈见女朋友吗？”听这口吻，我立马知道对方是为推销护眼类药物而来，像是突然没了什么顾虑般，点开了通话扬声器，一边带着戏谑的语气道。“首先你得有一个女朋友”我的声音很快从四周传递回来，这样的语气，在流火的七月里无疑是一阵清凉。“那你想要带着黑眼圈找女朋友吗？”听筒那边很快传来回复。这女人想卖产品想疯了，白费我一番戏谑的心思。我微微皱眉“我对你要推销的产品一点兴趣也没有”过了几秒又悠然道，“推销产品时你应该先说出一些令人困扰的现状，让你的听众能够在这些困扰中找到认同感，然后告诉他们可能改善的方法，最后引出你要卖的东西。”“你会买吗？”好像怕我没理解，那头又补充道，“如果按你那样说，你会买吗？”“不会”，我说的很快，我很想在她解释之前说完，我生怕她觉得我是那种需要听解释才能懂的人。“你刚才说了什么？”“我说不会，我是那种怎么看电视怎么熬夜眼睛都不会坏的人。”不得不说我确实有双好眼睛，讲这句话的时候我甚至有种自豪感。“你说话真有趣，你也是做微商么”“不是”，然后有点炫耀地说道，“我是个程序员”“嗯？程序员？经常看电脑吧？是不是经常眼睛觉得疲劳？”开始那种性感的声音此时已经蜕变得冷静。“对，偶尔会酸酸的。。。”还没说完，那边响起丝丝笑声，而后又平静下来。“是不是脑袋也会嗡嗡响，太阳穴也会疼，你应该时不时站起来活动下，看看远处，洗把脸。”她顿了顿，好像在水里憋了好久的气。“我最近看到一款对眼睛很好的产品”，她是笑着说这句话的，笑得很大声。我必须得承认这个女子的聪明，有时候我也像她一样。然而此刻我没有说话，一直沉静着。她似乎察觉到自己的失态，于是赶忙停住笑声，这种戛然而止，无异于从一匹纯种白猫身上硬生生长出一撮黑毛。只见那只猫的嘴又动了。“你做程序员一个月多少钱？”我没有仔细去辩证她的问题是否转变得过于突兀，只是支吾道，“嗯…六千、或者七千、大概有八千吧。”我忘了我只是想做一个程序员，到目前为止，并不是。听到这个，那张脸好像又变了，无线电波中都带着嘲讽的意味，“我们做微商一个月随随便便上万，听你说话对销售还颇有天赋，不如加入我们吧。”“其实我并没有什么销售天赋，我就是站在对方的角度想问题，对了，你们除了卖护眼类的还有什么其它的么？”“那你需要什么呢”，她立马回答，这就是一个商人的惯性，就像“can i help you”类的蠢话。“永远保留客户选择的权利，永远不要让自己扎进死胡同。我随便说一个你们没有的东西，你就接不了话了。”我很神气地回她，好像出了口程序员工资没她高的恶气。她好像并未因此气馁，她的声音甜得近乎暧昧，“像你这样的人才不做微商真是可惜了。”“我不喜欢微商，我讨厌销售。”我喊起来。挂掉电话，回音还在继续，我从没仔细听过自己的音色，此时，觉得跟夜深人静处的狗吠很像。我是个瞎子，干嘛要买护眼产品，而一个瞎子，难道能做销售吗？一个月前，我开始有变成瞎子的动向，这些，都是在很久之后才觉悟到。一开始的时候，只是晚一点去食堂吃饭，后来演变成躲在角落吃饭，再后来是打饭都塞着耳机，前几日已经要戴着帽子才敢去食堂了。这一过程中我慢慢出现幻觉，也会幻听，夜了也不开灯，喜欢躺着，看大量的故事，却懒得动笔。至此为止，我都没变成一个瞎子。然而昨天的那场面试，却把我死死打入瞎子的地狱。这个月来，我陆陆续续参加过许多场面试，大多数无疾而终。我以为，这次也一样。从电梯上走出来的时候，旁边是群谈论高级历史的年轻烟民，“秦始皇上六代分别叫什么名字”，这个声音来自一名穿棕色仿牛皮人字拖、脱水的半截海蓝牛仔裤的亢奋男子，他脸型偏瘦，脸色像极了吸水后的焦黄烟蒂，原本应该呈现的自然忧虑的眉目，此刻毅然舒展开，与他嘴角的一丝弧度交相呼应。我很快走过他们，我自诩博览群书却回答不出他的问题，只知道答案中有个嬴字。面试公司就在转弯的第一处入口，一扇玻璃门半掩着，正对门是一堵冰淇淋色的隔墙，上面彩绘着xx科技有限公司几个大字，门的左边摆一张纵向的咖啡木案，除了几封松弛的蓝底文件夹，其上再无他物。那堵墙的右边，也就是这半掩着的门的后面，应该就是真正的办公地点，只是此刻隔着不全透明的玻璃望去，却有几分像犹抱琵琶的歌女。推门进去之后，便看到琵琶遮住的全貌，木案的前方，是张小巧的圆形桌子，颜色呈深黑，之间夹杂一些淡雅的不规则浮纹，边缘被精心打磨过，人影经掠处，显现出一种复古的贵金属光晕。桌子向后三米，就到了真的办公区，地面沿那堵横墙分开，往下，要低一个门槛的高度，那里是踏踏实实的水泥地，与这边的青花瓷砖相比，破落的像是三流城镇里的年修国道。在那之上，摆放着两排背向的电脑，在我目光流转下迅速向两旁排列开去。“我是过来面试的”，我边说边朝前台走。前台是只很温顺的妹子，她指了指我身后的圆桌，“先坐会儿吧。”我回头看了一眼，就是刚刚看到的那张桌子，那儿正坐着三个人，三名女性。她们低着头在写些什么。我没说话，只是安静地向外走去。左边走廊的尽头传来断续的女子对话，时而嬉笑，时而哀叹，我能猜到她们是时尚的妙龄女郎，还有一个摄影师，她们丝毫不为自己的美丽感到担忧，游离在光与影的稍纵即逝里。我来回踱步，或是低头沉思，或是徒对天花，偶尔停下在墙壁上画上几笔抽象的名迹，一边还用余光瞄两眼门后的三人小圆桌。约莫过了六七分钟，出来一个接电话的男子，声音很浑厚，方言也听不懂，语气倒是比之前的电梯烟民俏皮些，我未及仔细看清他的样子，便顺着他拉开的门缝钻进去了。桌子边上只留下一个人，头发染成橙红色，落在肩上的发梢翘起微卷的尾巴，我移步桌子，坐在离她150度角的饮水机的斜前方。前台妹子见我过来就让填了信息表，顺带帮我们两个人到了一杯水，橙红色女郎显得有些讶异，抬起头的时候连忙说了声谢谢。很快，桌子边只剩我了，那女子被带进去的时候喝了口水，我听说人紧张的时候喉咙就会变得很干，所以她喝之后没多久我也喝了，不过是自己带的水，我以为，只要不喝别人的水，就不用说谢谢。开始有很多人走动，很多人来我身后的饮水机装水，出去接电话的男子也回来了，甚至那群电梯烟民也进来了，跟着进来的还有一名无害的龅牙妹。我惶恐于那群烟民同属这家公司，我深怕成为这提出“秦始皇上六代叫什么名字”的高级学问的文化人的同僚。然而令人庆幸的是，那个无害的龅牙妹依然无所适从的笑着，她作为一个同我一样的求职者，好像对此习以为常。她对着身份证填个人信息，从百度文库偌大的自然段中寻找自己的优缺点，我不禁笑出来，好像听到这个世上最好笑的笑话。在我进入面试之前，有个手拿相机的男子冲进来，一小会又急匆匆的跑出去，这样的画面，在我跟hr聊的时候一直闪现着，究竟是什么使得他这样紧迫呢。有那么一瞬间，我看到龅牙妹和另一名女性面对着坐在沙发上，她们一样无害，一样笑容可掬。也是在那一瞬间，又变得模糊，好像她们并没有出现过。聊以慰藉的交谈总让人寂寞，我就一直接受着来自寂寞的字眼，无论多么喋喋不休。我的心，早已随着18层高楼下小的可怜的汽车引擎逃离。出去的时候，那些看电影的人依然在看电影，玩游戏的依然在玩游戏，聊天的依然在聊天，我同前台的妹子挥手告别，推开门的瞬间，室内节能灯在茶色地板上投下巨大的黑影。我不知道所谓瞎子的定义，我把自己关在柜子里，四周一片黑暗。微弱的回音从黑暗中荡开去，然而没有人听到，那是手机铃声。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]},{"title":"由零开始","date":"2016-07-24T10:56:14.000Z","path":"2016/07/24/you ling kai shi/","text":"从凌晨一刻开始，我已经整整四个钟头没写一句话，洗手台下面的水管一直漏水，昨天我就发现了，也可能是前天，水就这么稀里里地流，我能想象它把房间充满，湿漉漉的被子死死压在身上，重得像这茫茫夜色的寂静，然而，除了夜什么也没发生。此时，房间另一边传来吱呀吱呀的声音，是突然侧身的室友，我急忙把手机屏亮起来，紧接着去床底下摸索出一盘蚊香，我想只有点上什么才能够逃脱，即使连一只蚊子也没有。 早上大概九点钟醒，一夜难眠，此刻兴致反倒高昂得紧，好像终于要开始什么伟大的事，毫不夸张地说，这股精神劲还是有生以来头一次。一切准备妥当，再去洗手台刮胡子，抹上一点肥皂水，尽量均匀些，不锈钢刀片沿上颚下巴来回律动着，欢快的节奏，如同远古深山里叮咚的清泉，不消尝一口，便已醉如泥泞。仿佛为了印证上述功效，室友一脸朦胧，以一个侧身盲点的位置伸手往床下探，约莫从他的鞋上晃三五次以后，我才恍然记起，他是在找袜子。十分钟前，我把房间重新整理了下，他的袜子作为房里最脏的东西之一，自然不能幸免，你可以想象得出，袜子是以怎样的痕迹从我手中落入垃圾娄，它简直是这个世界上最完美的抛物线，袜子对它饰演了这一杰作表示非常荣幸，所以正自鸣得意地待在垃圾娄的最底部。室友已经坐起来了，他蹙眉凝视，我想他已经很清楚了，他一直引以为傲的袜子，不存在了，但我没有因此同情他，反而我认为他表情转变得太过粗鲁，毕竟他只是为了印证功效才出现的。先不言他，此时我已经把胡子刮得一干二净，老实说，镜子里的这幅尊容比昨天不止漂亮上十倍，我讲这话的意思不是说昨天因为我外貌差了零点零一分而拒绝我的女孩今天就会接受我，我只是想陈述某件事实——我要出去面试了，因为零的倍数只可能是零，我始终不能靠脸吃饭。出门的时候，室友提醒我把垃圾也顺带扔了，我努了努嘴始终没有说话，我想，让一个人自己放弃一样东西很难，不如由他人代劳。 夏季的水泥路显然有些烫脚，我不得不以一个可笑的袋鼠跳的方式从树荫间穿过，原本并非一定要这样走，然而三食堂重新装修，这使得我必须再去找新的吃饭的地方，那儿步行的话将近有十分钟的路程。我想起两个月后到任的新承包商，他是原先二楼卖手抓饼的老板，对这个男人，并没多深刻的印象，看起来务实，矜矜业业。但很赏识老板娘，长相清秀，手艺精湛，会因为加了我不喜欢的香菜而重新做过，看得出来，她对她所从事职业的热爱，所以当我听说是她要承包整个食堂的时候，我第一个念头是，以后每个窗口都卖手抓饼。正是抱着这样的念头，我来到了正常营业的一食堂的门口。 里面人声鼎沸，只在门外，仿佛便有一种要被吞没的压迫感，各式各样的佐料味、汗味、本地产的廉价啤酒味、以及看起来格格不入的时尚女郎身上抹的香水味，它们像散发的彩虹的某一色光，在1q84小小人的带领下彼此厮杀着，然而又不能完全消灭，我看在眼里，却并未因此却步，再残酷也都要进去，都要吃饭。 等我打饭回来，并没直接去平时坐的座位，至于原因，那又是另一件事了。今天吃饭吃得比平时早了很多，虽然在时间上来说也不算早，但从我的生物钟看，它早得近乎异常。你要知道，这世上还有另一种人，他们享受孤独，只在人少的时候出没，像夜行的猫头鹰，敏锐、附有想象空间、又独具一格。我朝平日坐的位置看了两眼，然后选了它对面下一排的桌子，我就这样一边吃饭一边审视着对面那个座位。她妆容清秀，长头发，白色衬衣，没有破洞的蓝色牛仔裤，不过时的白底简约系带凉鞋，但是没有高跟，按鲁迅先生的原话，应该说标致极了，她安然霸占了我吃饭的宝地，以一种比我优雅多了的吃相被我审视着，我想，她究竟是迫于什么非要选择的这个位置。 要么她是同我一样类型的人物，首先不得不说那个位置在地理上已是绝佳——靠墙的一角，偏偏它对面的座位上还放着一顶迷彩军帽，不管出于什么，一般人都很难盯上这里，就连我，也是在连续使用洞察之眼的几回合后，才明白它正是为我这样注定成为王者的人而存在。所以当我第一次端着碗走向它的时候，我颤颤巍巍看了好久，从整个椅子的结构，到涂漆色泽，到颜料均匀度，连焊接口锈斑的小小瑕疵，都像是量身打造，无一不令人满意。我用手轻轻地去碰它，只在那一刹那，我发誓我被电到了，就像第一次牵心仪姑娘的手那样，电流从手的一端流经全身最后传到拿碗的那只手，在电流到达手指的零点零一秒内，我把碗筷放到了桌上，与其说放，不如说掉，我深怕因此而出名，这对于一个即将成为王者的人来说，是耻辱。碗筷放好，我把一只脚穿过桌子的承重架，另一只脚落在架子上，整个胯部被拉开一高一低，这样的姿势，让我有股学某种动物留下标志的冲动。考虑了约莫两分钟，才作罢，谁能凭爱意要富士山私有。当我马上就要找到什么词来形容我当时是如何把另一只脚放下的时候，不远处传来了玻璃酒瓶碎掉的声音。 不知你有没有遇过，因为你即将完成一件伟大的事，它看起来很近，却总是困难重重，我把这类事情归于命运的嫉妒。玻璃酒瓶碎了很明显属于此，《盗梦空间》里把音乐声当作梦醒的标志，它本身并不能唤醒任何人，它只是通知所有人你应该醒了。所以下一秒钟，我看到了令我排除以上假设——女孩与我同一类人的一幕。她略带惊恐地看向声源地，脚不自觉改变了所朝的方向，可能的话，她应该已经身处数米之外了。她是个爱看热闹的人，我马上下了如此的定论，这并非一只猫头鹰应禀有的天赋，它不过一场酒味小小人请求援军的闹剧。为此我只好重新思考有关她坐在那个位置的罪证。 曾经看过这么一部电影，女孩在恋人去世之后仍保持他存在着的记忆，比如，经常到小区附近的西餐厅点两份同样的意大利面，然而只吃一份；经常去学士路尽头的照相馆洗两份同样的生活照，却只拿走一份；经常从路过的某个未知名的零售店买两份同样的冰淇淋，而看着另一份融化。我一面否定女孩的行为，一面羡慕她的命运，她以一种近乎病态的爱来证明人们对于浪漫盲目般的憧憬，让每一代的俊男靓女前赴后继地追逐这个概率，满足一个情怀，或者寻找一种解脱。不管是什么，此时此刻，我已然把这顶帽子结结实实扣到眼前姑娘头上，是从她对面座位上拿的隶属于她已逝去恋人的帽子，她必须是这样的人，别无可能。吃完饭后，我悄然离开，我早该离开，甚至不该进来。 食堂前被赶出来的老头木箱里的啤酒只剩下几瓶，我看着从酒瓶瓶颈往下流的液化水汽，感觉天更热了。 原本想抄小路过桥快速到达公车站，途经清心亭的时候却被半个河面的莲花吸引，于是驻足拍了张照。我想起几日前从外面试回来时，有人问过荷花池在什么地方，当时含糊此处并无荷花云云，此刻见河中接天莲叶别样红，不禁抹了抹额角的细汗，一边还要骂上几句太阳的狠话。 过了李冰父子像就到了桥上，前面是干净的没有半根水草的河面，反倒是河沿的两侧满是半人高的芦苇，风沿着河面吹来，在芦苇倾斜间形成一股刺脸的热浪，而就在这一动一静之间，我看到不远处一个年轻的充满活力的垂钓者，之所以这么形容，是出于其对垂钓时间的把握，现在正是晌午，又哪里来的不怕热的鱼。转念一想，既然此刻有人站在这里看他钓，那这渔人也并非没有钓到鱼的可能，姜太公直钩尚且钓到周文王，就好像右边这十里荷花，没有开的时候，又有谁知道它的存在呢？ 一点二十二分下车，离约好面试的时间差三十八分钟，我没有直接去面试地点等，而是待在下车那个站台的后面的草坪一侧看书，看的是菲茨杰拉德的《人间天堂》,一直到一点五十四再去的面试处，期间公路的另一侧修剪草坪，这种大自然泥草的清新味道，只在原来割稻谷的时候闻到，而现在应该就是收割稻谷的时令了。我一边惶恐于自己的衣食无忧，一边没入林立的高楼大厦。 面试我的是个称得上漂亮的女人，面目清秀，身材匀称，头发整齐地落在肩上，流行的空气刘海因为长长有点黏住额角，言辞犀利，讲话时右手会把左手的食指握住，中指戴着一颗有点胖的金色转运珠，在手部的细微动作下格外引人注目。陆小凤说漂亮的女人最可怕，眼前的这位无疑就是一个，我们谈论了将近三个小时，之间我很怕因为她精湛的职场分析和层级的利诱技巧而改变来时的决议，索性我告诉她了，我只是想把最后一份简历送出去，我跟你们公司没什么仇，但我跟他们是两种人，而我不想变成他们。面试完毕后又聊了会儿，纯粹是消磨时光，听别人的故事，然后羡慕、嫉妒、或者同情，其实没什么两样，你依旧是这高级建材间的跳梁小丑，依旧做好本该悲哀者的觉悟。 一直拖到他们公司开会才离开，坐电梯下楼时差点从中途又出去，好在被人叫回来。沿公路外侧的人形道往回走，在第一个路口的支路向右转，我数着对面交通信号灯的秒数，整了整因为重新出汗而黏在背部的棉质衬衫。此时，太阳已经西沉，公交站的金属路牌上反射出季节的余热。 夜色降临的时候，我人在足球场地跑道上，我不知道跑了多少圈，只知道还没有虚脱。王小波说他总是不让自己闲起来，实在闲的时候就去外面跑步，这能有效避免手淫，我不排除这一功效，我跑步的原因是让自己虚脱，它能有效避免一切，包括思考。但是现在，显然没有达到这一效果。回来的时候，我点了一支烟，烟是六月中旬买的，芙蓉王，原本打算给投靠的同学抽，后来没有去，就一直留在书包里，已经将近一个月，烟只少了十分之一。我是个讨厌烟味的人，我告诉面试我的那个漂亮女人，我跟她解释，我讨厌的是那种吸入的烟的味道，不是烟本身，对我来说，烟草其实就和茶叶一样。我想起一句歌词“像我在往日还没抽烟”，很难想象，如今烟、酒竟成了愁绪的代名词，好像一拿起一支烟就是多么不开心一样，为什么要人为的去制造某种情绪的氛围，以此渲染肤浅的近似表演的戏剧色彩。我连续点了十八支烟，它们从此不再占用我的背包空间，不再有负重，连带着打火机也不用了，不听那些大道理，我依然可以过好这一生。 以上就是我他妈的漫长的一天。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]},{"title":"我为什么活着","date":"2016-07-14T18:11:30.000Z","path":"2016/07/15/wo wei shen me huo zhe/","text":"想写这篇文已经是几天之前，而真正开始动笔却是在这燥热的凌晨一点半。我想，人之所以还活着的理由，大概是为了反驳他的懒惰和一无是处。在我已完结的短暂生命里，有过爱恨，有过哀乐，有过离别与重逢，有过失望和期望，我以为我经历的已经是我的全部，而接下去的日子似乎变得无足轻重，开始在时间上堕落，就好像左手做了一件明知错误的事，右手却埋在深深的自责之中。我知道我沦落到了某个边缘之上，当我问自己你为什么而活的时候，我很诧异我究竟找不到什么确切的字眼形容。入夜的风同这无边的黑色一样，虽然不知道它确切地从哪里开始，到哪里结束，却一直真实存在着。 十五年前我刚上学，爷爷是在那年去世的，头七当天晚上，我们聚在未分家前的老屋子里折草纸冥具，等走完仪式，便按着曲折小路回实际的住处，路过一家废宅时，看到有零星的萤火虫熠熠飞过。那是七月份吧，大概只有七月份才会有萤火虫，夏季的晴晚，月光在银色系带中移过头顶。听到大伯谈姐姐的学习情况，说以后要和小叔一样做个文化人，那时姐姐成绩很好，她和小叔相差十五岁，十五年后她或许真的会成为文化人，那我呢？那我呢，我曾无数次从这间废宅走过，但我从来没想过十五年后我会成为什么样子，我只是好奇这间屋子的拥有者去哪里了，为什么破旧的门板上每年都会换新的对联。人总有某种归属感，活着的时候归属一间屋子，一间总是换着门联的废宅；死了，便归属坟墓，立一个碑，也要学活的时候搞个联子，做还活着的假象。 究竟为了什么而活着呢，或者说为什么活着才好呢，我想首先我得明白我，我想要什么，生活能给我什么，我又能改变什么。这些无非就是万事向前看的废话，因为到此为止你所获得的可能根本微不足道，甚至无所谓有无，在新的时间段里，它大多被遗忘，当你怀揣某种既定目标面向未来，希望能够得到一些有意义的回报，然后遇到一些人，又或者和一些人分开，然而，这些不过作为更远未来的过去又被遗忘，除此之外，便被胡乱记在歌词华丽的谎言里，“往事就像是一道桥，你我会过去的，情怀不会倒退”。 曾经我很信服村上在《挪》里写的“死不是生的对立面而作为生的一部分永存”，也因此会无缘故萌生一种自杀的冲动，我把心隔离在水银温度计的一端，总希冀有那么一个人能让我热到足以冲破禁锢，从那时起便有了恋人。当你喜欢什么人的时候，会觉得时光很短，剩下的日子都用来思念，而一旦想到死亡，便硬生生堕入虚无，怕从未留下什么证明你们爱过。令我没想到的是，恋人，并非一座桥而是一艘船，你始终在温度计里，只不过有了依靠，在飘摇里安定，在热血中平凡。或者，你会想，哪一天，你们结婚，有了小孩，抚育他们成人，尔后，苍老，从年华的景深中淡去。这时候，再记起王先生所作“况修短随化，终期于尽”的句子，“未尝不临文嗟悼，不能喻之于怀”。 死生向来同命运相关，而我又不是信命的人，很小时起就认为人应该是运命的，想来这亦是人类作为地球霸主屹立不倒的缘由之一，正是不同的命运和命运的交集缔造了不同的文明和文明的发展，事实上大部分人都是被命运奴役的，如同1984中所说“个人记忆被集体记忆掩盖”。一个人在自己记忆被忘却时能够怀疑自我的真实性，这是独立思考的基础，也是我活着另一个理由。我身边有太多这样的人——他老实、努力、很少犯错、生活规律——我只需见上一面就能看清他的未来。他所信任的不应该是真理部创造的，而是通过自我思考得到的，人存在的意义是为了给世界创出价值，而非其它生命，随历史的轮转消逝殆尽，我悟到了，那他们呢？ 这些年来，我一直如此苟活着，身边不停有人死去，每次母亲告诉我又有谁离世时，我没有一丝怜悯。这世上原本就有死生，那些曾经陪在身边的人，哪一天突然离开，这便是死，哪一天偶然重遇，这又是生，至于他是不是他，是死是生，已不重要，佛说，刹那即是永恒，一息便有轮回。 时间是永恒的参照，思维才是永恒，相对论中讲当速度等于光速，时间就会静止，超过光速，就能知晓未来，那过去呢，它被永远埋葬。人是思维的载体，它拥有思考这个方法，当他存在思维时，思考便作为一个永真式一直循环下去，每个人能都继承自这个类，重写它的思考方法，而以上便是我思考方法体的一部分。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.luofeng.tk/tags/随笔/"}]}]